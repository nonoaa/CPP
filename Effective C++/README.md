# Effective C++

## 항목1: C++를 언어들의 연합체로 바라보는 안목은 필수
- C++는 4개의 하위 언어를 제공한다.
	- C
	- 객체 지향 개념의 C++
	- 템플릿 C++
	- STL

## 항목2: #define을 쓰려거든 const, enum, inline을 떠올리자
- 단순한 상수를 쓸 때는 #define보다 const 객체 혹은 enum을 우선 생각하자
- 함수처럼 쓰이는 매크로를 만들려면, #define 매크로보다 인라인 함수를 우선 생각하자
	- 인라인 함수
		- 컴파일된 함수 코드가 프로그램의 코드 안에 직접 삽입되므로 현재 명령어의 주소를 저장하고 함수의 주소로 왔다갔다하는 과정이 필요가 없어 프로그램의 속도가 빨라질 수 있다.
		- 컴파일러가 인라인 함수의 사본을 호출한 부분에 계속해서 삽입해야 되기 때문에 그만큼 메모리의 낭비가 있을 수 있다.
		- 따라서 인라인 함수를 사용하기에 적절한 상황은 호출이 많이 일어나지 않는 함수이거나 함수 내부의 실행속도가 짧은데 비해 함수의 호출 시간이 부담스러울 때 사용하는 것이 좋다.

## 항목3: 낌새만 보이면 cons를 들이대 보자!
- const를 붙여 선언하면 컴파일러가 사용상의 에러를 잡아내는 데 도움을 준다. const는 어떤 유효범위에 있는 객체에도 붙을 수 있으며, 함수 매개변수 및 반환 타입에도 붙을 수 있으며, 멤버 함수에도 붙을 수 있다.
- 컴파일러 쪽에서 보면 비트수준 상수성을 지켜야 하지만, 개념적인(논리적인) 상수성을 사용해서 프로그래밍하자.
	- 비트수준 상수성
		- C++가 적용하고 있는 상수성인데 상수 멤버 함수가 객체의 어떤 멤버 변수도 건드려지지 않아야 비트수준 상수성이다.
		- 하지만 아래와 같은 경우, Hello가 Jello로 바뀌면서 비트수준 상수성을 회피할 가능성이 있다.
		```cpp
		class CTextBlock
		{
		public:
		.....
			char& operator[](std::size_t position) const
			{return pText[position];}   
			
		private:
			char *pText;
		}

		const CTextBlock CCTb("Hello");
		char *pc = &CCTb[0];
		*pc = 'J';
		```
	- 논리적 상수성
		- 논리적 상수성이란 개념은 이런 상황을 보완하는 대체 개념으로 나오게 되었다. 상수 멤버 함수라고 해서 객체의 한 비트도 수정할 수 없는 것이 아니라 일부 몇 비트 정도는 바꿀 수 있되, 그것을 사용자측에서 알아채지 못하기만 하면 상수 멤버 자격이 있다는 것이다.
		- mutable 키워드
			- 멤버 변수를 mutable로 선언하였다면 const 함수 내부에서도 값을 변경 가능하게 만들어준다.

- 상수 멤버 및 비상수 멤버 함수가 기능적으로 서로 똑같게 구현되어 있을 경우에는 코드 중복을 피하는 것이 좋은데, 이때 비상수 버전이 상수 버전을 호출하도록 만드세요
	- *this에 static_cast로 const를 붙여서 상수버전 함수를 호출하고, const_cast를 이용해 const를 떼어낸 값을 리턴한다.
	```cpp
	class TextBlock
	{
		public:
		....
		const char& operator[](std::size_t position) const
		{	....
			....
			return text[position];
			}
		
		char& operator[] (std::size_t position)
		{	
			return 
				const_cast<char&>(				//op[]의 반환타입에 캐스팅을 적용
												//const를 떼어낸다
				static_cast<const TextBlock&>		//*this의 타입에 const를 붙인다
				(*this)[position];
				)				//op[]의 상수 버전을 호출한다.
		}
	}
	```

## 항목4: 객체를 사용하기 전에 반드시 그 객체를 초기화하자
- 기본제공 타입의 객체는 직접 손으로 초기화하자. 경우에 따라 저절로 되기도 하고 안되기도 하기 때문이다.
- 생성자에서는, 데이터 멤버에 대한 대입문을 생성자 본문 내부에 넣는 방법으로 멤버를 초기화하지 말고 멤버 초기화 리스트를 즐겨 사용하자. 그리고 초기화 리스트에 데이터 멤버를 나열할 때는 클래스에 각 데이터 멤버가 선언된 순서와 똑같이 나열하자.
	- 초기화 리스트 나열순서에 상관없이 초기화는 데이터 멤버의 선언 순서대로 이루어진다. 알아보기 쉽게 데이터 멤버가 선언된 순서와 똑같이 나열해주는 것이 좋다.
- 여러 번역 단위에 있는 비지역 정적 객체들의 초기화 순서 문제는 피해서 설계해야 한다. 비지역 정적 객체를 지역 정적 객체로 바꾸면 된다.
	- 정적 객체(static object)
		- 자신이 생성된 시점부터 프로그램이 끝날 때까지 살아 있는 객체
		- 정적 객체의 범주에 들어가는 것들 (함수 안에 있는 정적 객체는 지역 정적 객체, 나머지는 비지역 정적 객체라고 한다.)
			- 전역 객체
			- 네임스페이스 유효범위에서 정의된 객체
			- 클래스 안에서 static으로 선언된 객체
			- 함수 안에서 static으로 선언된 객체
			- 파일 유효범위에서 static으로 정의된 객체
		- main() 함수의 실행이 끝날 때 정적 객체의 소멸자가 호출된다.
		- static과 extern
			- static: 현재 파일 내에서만 존재하는 파일의 지역변수 취급을 받기 때문에 이름이 같더라도 서로 다른 파일에서 각각 다른 변수로 취급이 된다. 따라서 static 변수를 통해 혹시 모를 전역변수의 이름이 같게되는 문제를 조금이나마 완화할 수 있다.
			- extern: 다른 파일의 변수를 공유 가능하다. extern은 다른 파일의 함수나 변수를 가져오는 것 이외에도 현재 파일 내에서도 작동 가능하다.
	- 번역 단위
		- 컴파일을 통해 하나의 목적 파일(object file)을 만드는 바탕이 되는 소스 코드
		- 기본적으로는 소스 파일 하나가 되는데, 그 파일이 #include 하는 파일들까지 합쳐서 하나의 번역 단위가 된다.
	- 서로 다른 번역 단위에 정의된 비지역 정적 객체들의 상대적인 초기화 순서는 정해져 있지 않다.
	- 초기화 순서 문제 피하기
	```cpp
	class FileSystem {...};

	//extern FileSystem tfs; 기존 코드

	FileSystem tfs()
	{
		static FileSystem fs;
		return fs;
	}

	class Directory {...};

	Directory::Directory(params)
	{
		...
		// std::size_t disks = tfs.numbers(); 기존 코드
		std::size_t disks = tfs().numbers();
	}

	// Directory tempDir(params) 기존 코드
	Directory& tempDir()
	{
		static Directory td;
		return td;
	}
	```

## 항목5: C++가 은근슬쩍 만들어 호출해 버리는 함수들에 촉각을 세우자
- 컴파일러는 경우데 따라 클래스에 대해 기본 생성자, 복사 생성자, 복사 대입 연산자, 소멸자를 암시적으로 만들어 놓을 수 있다.

## 항목6: 컴파일러가 만들어낸 함수가 필요 없으면 확실히 이들의 사용을 금해 버리자
- 컴파일러에서 자동으로 제공하는 기능을 허용치 않으려면, 대응되는 멤버 함수를 private으로 선언한 후에 구현은 하지 않은 채로 두자. Uncopyable과 비슷한 클래스를 쓰는 것도 한 방법이다.
	```cpp
	class Uncopyable
	{
	protected:
		Uncopyable() {}
		~Uncopyable() {}   // 생성과 소멸을 허용
	private:
		Uncopyable(const Uncopyable&);
		Uncopyable& operator=(const Uncopyable&); // 복사와 대입연산자 방지
	}

	class HomeForSale: private Uncopyable { // 상속이 public일 필요가 없다.
	// 복사 생성자, 복사 대입 연산자가 선언되지 않는다.
	...
	}
	```
	- 부스트 라이브러리를 보면 비슷한 noncopyable이 있다.

## 항목7: 다형성을 가진 기본 클래스에서는 소멸자를 반드시 가상 소멸자로 선언하자
- 다형성을 가진 기본 클래스에는 반드시 가상 소멸자를 선언해야 한다. 즉, 어떤 클래스가 가상 함수를 하나라도 갖고 있으면, 이 클래스의 소멸자도 가상 소멸자여야 한다.
- 기본 클래스로 설계되지 않았거나 다형성을 갖도록 설계되지 않은 클래스에는 가상 소멸자를 선언하지 말아야 한다.
	- 32비트에서는 4바이트, 64비트에서는 8바이트만큼 객체의 크기가 커진다.
	- C 등의 다른 언어로 선언된 동일한 자료구조와도 호환성이 없어진다. 가상함수 테이블 포인터를 어떻게 만들 수가 없기 때문이다.
- STL 컨테이너 타입 전부가 가상 소멸자가 없는 클래스이다. 이 클래스를 상속받아 사용할 경우 소멸자가 선언되지 않아 문제가 발생할 수 있다.

## 항목8: 예외가 소멸자를 떠나지 못하도록 붙들어 놓자
- 소멸자에서는 예외가 빠져나가면 안 된다. 만약 소멸자 안에서 호출된 함수가 예외를 던질 가능성이 있다면, 어떤 예외이든지 소멸자에서 모두 받아낸 후에 삼켜 버리던지 프로그램을 끝내던지 해야 한다.
- 어떤 클래스의 연산이 진행되다가 던진 예외에 대해 사용자가 반응해야 할 필요가 있다면, 해당 연산을 제공하는 함수는 반드시 보통의 함수(즉, 소멸자가 아닌 함수)이어야 한다.
```cpp
class DBConn
{
public:
	...
	void close() // 사용자 호출을 배려해서 새로 만든 함수
	{
		db.close();
		closed = true;
	}

	~DBConn()
	{
		if (!closed) // 사용자가 연결을 안 닫았으면 여기서 닫는다
		{
			try{
				db.close();
			}
			catch(...) // 연결을 닫다가 실패하면, 실패를 알린 후에 실행을 끝내거나 예외를 삼킨다.
			{
				close 호출이 실패했다는 로그 작성;
			}
		}
	}
private:
	DBConnection db;
	bool closed;
}
```

## 항목9: 객체 생성 및 소멸 과정 중에는 절대로 가상 함수를 호출하지 말자
- 생성자 혹은 소멸자 안에서 가상 함수를 호출하지 말자. 가상 함수라고 해도, 지금 생성중인 생성자나 소멸자에 해당되는 클래스의 파생 클래스 쪽으로는 내려가지 않기 때문이다.
	- 기본 클래스 생성 과정에서는 가상 함수가 먹히지 않는다.
	- 필요한 파생 클래스에서 기본 클래스 생성자로 '올려'주도록 만듦으로써 부족한 부분을 역으로 채울 수 있다.

## 항목10: 대입 연산자는 *this의 참조자를 반환하게 하자
- 대입 연산자는 *this의 참조자를 반환하도록 만들자
```cpp
class Widget {
public:
	...
	Widget& operator=(const Widget& rhs)
	{
		...
		return *this;
	}

	Widget& operator+=(const Widget &rhs)
	{
		...
		return *this;
	}
}
```

## 항목11: operator=에서는 자기대입에 대한 처리가 빠지지 않도록 하자
- operator=을 구현할 때, 어떤 객체가 그 자신에 대입되는 경우를 제대로 처리하도록 만들자. 원본 객체와 복사대상 객체의 주소를 비교해도 되고, 문장의 순서를 적절히 조정할 수도 있으며, temp에 복사 후 맞바꾸기 기법을 써도 된다.
- 두 개 이상의 객체에 대해 동작하는 함수가 있다면, 이 함수에 넘겨지는 객체들이 사실 같은 객체인 경우에 정확하게 동작하는지 확인해 보자.

## 항목12: 객체의 모든 부분을 빠짐없이 복사하자
- 객체 복사 함수는 주어진 객체의 모든 데이터 멤버 및 모든 기본 클래스 부분을 빠뜨리지 말고 복사해야 한다.
	- 상속 받은 경우 기본 클래스의 복사 함수를 호출하도록 만들자.
- 클래스의 복사 함수 두 개를 구현할 때, 한쪽을 이용해서 다른 쪽을 구현하려는 시도는 절대로 하지 말자. 그 대신, 공통된 동작을 제 3의 함수에다 분리해 놓고 양쪽에서 이것을 호출하게 만들어서 해결하자.

## 항목13: 자원 관리에는 객체가 그만!
- 자원 누출을 막기 위해, 생성자 안에서 자원을 획득하고 소멸자에서 그것을 해제하는 RAII 객체를 사용하자.
	- RAII(Resource Acquisition Is Initialization, 자원 획득 즉 초기화): 자원 획득과 자원 관리 객체의 초기화가 바로 한 문장에서 이루어지는 것
- 일반적으로 널리 쓰이는 RAII 클래스는 tr1::shared_ptr 그리고 auto_ptr이다. 이 둘 가운데 tr1::shared_ptr이 복사 시의 동작이 직관적이기 때문에 대개 더 좋다. 반면, auto_ptr은 복사되는 객체(원본 객체)를 null로 만들어 버린다.
	- 책이 2005년에 출판되어 auto_ptr이 언급되어 있지만 auto_ptr은 C++11부터 사용 중지 권고, C++17 이후에 제거 되었고 unique_ptr로 대체되었다.
	- auto_ptr의 문제점
		- new로 생성한 단일 객체에 대해서만 메모리의 해제를 보장한다. malloc 등으로 할당한 경우 해제가 불가능하다.
		- new[]로 메모리를 할당할 경우 메모리가 정상적으로 해제되지 않을 수 있다.
		- 동일한 메모리 위치를 가리키는 객체를 2개 이상 만들면 안된다.
	- std::unique_ptr
		- 복사 생성자를 delete로 명시적으로 삭제시켜 unique_ptr 객체를 복사하는 경우를 막는다.
		- std::move를 통해 소유권을 이전할 수 있다.
		- C++14부터 std::make_unique함수가 제공된다.
	- std::shared_ptr
