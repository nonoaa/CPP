# Effective C++

## 항목1: C++를 언어들의 연합체로 바라보는 안목은 필수
- C++는 4개의 하위 언어를 제공한다.
	- C
	- 객체 지향 개념의 C++
	- 템플릿 C++
	- STL

## 항목2: #define을 쓰려거든 const, enum, inline을 떠올리자
- 단순한 상수를 쓸 때는 #define보다 const 객체 혹은 enum을 우선 생각하자
- 함수처럼 쓰이는 매크로를 만들려면, #define 매크로보다 인라인 함수를 우선 생각하자
	- 인라인 함수
		- 컴파일된 함수 코드가 프로그램의 코드 안에 직접 삽입되므로 현재 명령어의 주소를 저장하고 함수의 주소로 왔다갔다하는 과정이 필요가 없어 프로그램의 속도가 빨라질 수 있다.
		- 컴파일러가 인라인 함수의 사본을 호출한 부분에 계속해서 삽입해야 되기 때문에 그만큼 메모리의 낭비가 있을 수 있다.
		- 따라서 인라인 함수를 사용하기에 적절한 상황은 호출이 많이 일어나지 않는 함수이거나 함수 내부의 실행속도가 짧은데 비해 함수의 호출 시간이 부담스러울 때 사용하는 것이 좋다.

## 항목3: 낌새만 보이면 cons를 들이대 보자!
- const를 붙여 선언하면 컴파일러가 사용상의 에러를 잡아내는 데 도움을 준다. const는 어떤 유효범위에 있는 객체에도 붙을 수 있으며, 함수 매개변수 및 반환 타입에도 붙을 수 있으며, 멤버 함수에도 붙을 수 있다.
- 컴파일러 쪽에서 보면 비트수준 상수성을 지켜야 하지만, 개념적인(논리적인) 상수성을 사용해서 프로그래밍하자.
	- 비트수준 상수성
		- C++가 적용하고 있는 상수성인데 상수 멤버 함수가 객체의 어떤 멤버 변수도 건드려지지 않아야 비트수준 상수성이다.
		- 하지만 아래와 같은 경우, Hello가 Jello로 바뀌면서 비트수준 상수성을 회피할 가능성이 있다.
		```cpp
		class CTextBlock
		{
		public:
		.....
			char& operator[](std::size_t position) const
			{return pText[position];}   
			
		private:
			char *pText;
		}

		const CTextBlock CCTb("Hello");
		char *pc = &CCTb[0];
		*pc = 'J';
		```
	- 논리적 상수성
		- 논리적 상수성이란 개념은 이런 상황을 보완하는 대체 개념으로 나오게 되었다. 상수 멤버 함수라고 해서 객체의 한 비트도 수정할 수 없는 것이 아니라 일부 몇 비트 정도는 바꿀 수 있되, 그것을 사용자측에서 알아채지 못하기만 하면 상수 멤버 자격이 있다는 것이다.

- 상수 멤버 및 비상수 멤버 함수가 기능적으로 서로 똑같게 구현되어 있을 경우에는 코드 중복을 피하는 것이 좋은데, 이때 비상수 버전이 상수 버전을 호출하도록 만드세요
	```cpp
	class TextBlock
	{
		public:
		....
		const char& operator[](std::size_t position) const
		{	....
			....
			return text[position];
			}
		
			char& operator[] (std::size_t position)
		{	
			return 
				const_cast<char&>				//op[]의 반환타입에 캐스팅을 적용
												//const를 떼어낸다
				(static_cast<const TextBlock&>		//*this의 타입에 const를 붙인다
				(*this)[position];				//op[]의 상수 버전을 호출한다.
		}
	}
	```