# Effective C++

## Chapter 1: C++에 왔으면 C++의 법을 따릅시다
### 항목1: C++를 언어들의 연합체로 바라보는 안목은 필수
- C++를 사용한 효과적인 프로그래밍 규칙은 경우에 따라 달라진다. 그 경우란, 바로 C++의 어떤 부분을 사용하느냐이다.
	- C++는 4개의 하위 언어를 제공한다.
		- C
		- 객체 지향 개념의 C++
		- 템플릿 C++
		- STL

### 항목2: #define을 쓰려거든 const, enum, inline을 떠올리자
- 단순한 상수를 쓸 때는 #define보다 const 객체 혹은 enum을 우선 생각하자
- 함수처럼 쓰이는 매크로를 만들려면, #define 매크로보다 인라인 함수를 우선 생각하자
	- 인라인 함수
		- 컴파일된 함수 코드가 프로그램의 코드 안에 직접 삽입되므로 현재 명령어의 주소를 저장하고 함수의 주소로 왔다갔다하는 과정이 필요가 없어 프로그램의 속도가 빨라질 수 있다.
		- 컴파일러가 인라인 함수의 사본을 호출한 부분에 계속해서 삽입해야 되기 때문에 그만큼 메모리의 낭비가 있을 수 있다.
		- 따라서 인라인 함수를 사용하기에 적절한 상황은 호출이 많이 일어나지 않는 함수이거나 함수 내부의 실행속도가 짧은데 비해 함수의 호출 시간이 부담스러울 때 사용하는 것이 좋다.

### 항목3: 낌새만 보이면 cons를 들이대 보자!
- const를 붙여 선언하면 컴파일러가 사용상의 에러를 잡아내는 데 도움을 준다. const는 어떤 유효범위에 있는 객체에도 붙을 수 있으며, 함수 매개변수 및 반환 타입에도 붙을 수 있으며, 멤버 함수에도 붙을 수 있다.
- 컴파일러 쪽에서 보면 비트수준 상수성을 지켜야 하지만, 개념적인(논리적인) 상수성을 사용해서 프로그래밍하자.
	- 비트수준 상수성
		- C++가 적용하고 있는 상수성인데 상수 멤버 함수가 객체의 어떤 멤버 변수도 건드려지지 않아야 비트수준 상수성이다.
		- 하지만 아래와 같은 경우, Hello가 Jello로 바뀌면서 비트수준 상수성을 회피할 가능성이 있다.
		```cpp
		class CTextBlock
		{
		public:
		.....
			char& operator[](std::size_t position) const
			{return pText[position];}   
			
		private:
			char *pText;
		}

		const CTextBlock CCTb("Hello");
		char *pc = &CCTb[0];
		*pc = 'J';
		```
	- 논리적 상수성
		- 논리적 상수성이란 개념은 이런 상황을 보완하는 대체 개념으로 나오게 되었다. 상수 멤버 함수라고 해서 객체의 한 비트도 수정할 수 없는 것이 아니라 일부 몇 비트 정도는 바꿀 수 있되, 그것을 사용자측에서 알아채지 못하기만 하면 상수 멤버 자격이 있다는 것이다.
		- mutable 키워드
			- 멤버 변수를 mutable로 선언하였다면 const 함수 내부에서도 값을 변경 가능하게 만들어준다.

- 상수 멤버 및 비상수 멤버 함수가 기능적으로 서로 똑같게 구현되어 있을 경우에는 코드 중복을 피하는 것이 좋은데, 이때 비상수 버전이 상수 버전을 호출하도록 만드세요
	- *this에 static_cast로 const를 붙여서 상수버전 함수를 호출하고, const_cast를 이용해 const를 떼어낸 값을 리턴한다.
	```cpp
	class TextBlock
	{
		public:
		....
		const char& operator[](std::size_t position) const
		{	....
			....
			return text[position];
			}
		
		char& operator[] (std::size_t position)
		{	
			return 
				const_cast<char&>(				//op[]의 반환타입에 캐스팅을 적용
												//const를 떼어낸다
				static_cast<const TextBlock&>		//*this의 타입에 const를 붙인다
				(*this)[position];
				)				//op[]의 상수 버전을 호출한다.
		}
	}
	```

### 항목4: 객체를 사용하기 전에 반드시 그 객체를 초기화하자
- 기본제공 타입의 객체는 직접 손으로 초기화하자. 경우에 따라 저절로 되기도 하고 안되기도 하기 때문이다.
- 생성자에서는, 데이터 멤버에 대한 대입문을 생성자 본문 내부에 넣는 방법으로 멤버를 초기화하지 말고 멤버 초기화 리스트를 즐겨 사용하자. 그리고 초기화 리스트에 데이터 멤버를 나열할 때는 클래스에 각 데이터 멤버가 선언된 순서와 똑같이 나열하자.
	- 초기화 리스트 나열순서에 상관없이 초기화는 데이터 멤버의 선언 순서대로 이루어진다. 알아보기 쉽게 데이터 멤버가 선언된 순서와 똑같이 나열해주는 것이 좋다.
- 여러 번역 단위에 있는 비지역 정적 객체들의 초기화 순서 문제는 피해서 설계해야 한다. 비지역 정적 객체를 지역 정적 객체로 바꾸면 된다.
	- 정적 객체(static object)
		- 자신이 생성된 시점부터 프로그램이 끝날 때까지 살아 있는 객체
		- 정적 객체의 범주에 들어가는 것들 (함수 안에 있는 정적 객체는 지역 정적 객체, 나머지는 비지역 정적 객체라고 한다.)
			- 전역 객체
			- 네임스페이스 유효범위에서 정의된 객체
			- 클래스 안에서 static으로 선언된 객체
			- 함수 안에서 static으로 선언된 객체
			- 파일 유효범위에서 static으로 정의된 객체
		- main() 함수의 실행이 끝날 때 정적 객체의 소멸자가 호출된다.
		- static과 extern
			- static: 현재 파일 내에서만 존재하는 파일의 지역변수 취급을 받기 때문에 이름이 같더라도 서로 다른 파일에서 각각 다른 변수로 취급이 된다. 따라서 static 변수를 통해 혹시 모를 전역변수의 이름이 같게되는 문제를 조금이나마 완화할 수 있다.
			- extern: 다른 파일의 변수를 공유 가능하다. extern은 다른 파일의 함수나 변수를 가져오는 것 이외에도 현재 파일 내에서도 작동 가능하다.
	- 번역 단위
		- 컴파일을 통해 하나의 목적 파일(object file)을 만드는 바탕이 되는 소스 코드
		- 기본적으로는 소스 파일 하나가 되는데, 그 파일이 #include 하는 파일들까지 합쳐서 하나의 번역 단위가 된다.
	- 서로 다른 번역 단위에 정의된 비지역 정적 객체들의 상대적인 초기화 순서는 정해져 있지 않다.
	- 초기화 순서 문제 피하기
	```cpp
	class FileSystem {...};

	//extern FileSystem tfs; 기존 코드

	FileSystem tfs()
	{
		static FileSystem fs;
		return fs;
	}

	class Directory {...};

	Directory::Directory(params)
	{
		...
		// std::size_t disks = tfs.numbers(); 기존 코드
		std::size_t disks = tfs().numbers();
	}

	// Directory tempDir(params) 기존 코드
	Directory& tempDir()
	{
		static Directory td;
		return td;
	}
	```

## Chapter 2: 생성자, 소멸자 및 대입 연산자
### 항목5: C++가 은근슬쩍 만들어 호출해 버리는 함수들에 촉각을 세우자
- 컴파일러는 경우데 따라 클래스에 대해 기본 생성자, 복사 생성자, 복사 대입 연산자, 소멸자를 암시적으로 만들어 놓을 수 있다.

### 항목6: 컴파일러가 만들어낸 함수가 필요 없으면 확실히 이들의 사용을 금해 버리자
- 컴파일러에서 자동으로 제공하는 기능을 허용치 않으려면, 대응되는 멤버 함수를 private으로 선언한 후에 구현은 하지 않은 채로 두자. Uncopyable과 비슷한 클래스를 쓰는 것도 한 방법이다.
	```cpp
	class Uncopyable
	{
	protected:
		Uncopyable() {}
		~Uncopyable() {}   // 생성과 소멸을 허용
	private:
		Uncopyable(const Uncopyable&);
		Uncopyable& operator=(const Uncopyable&); // 복사와 대입연산자 방지
	}

	class HomeForSale: private Uncopyable { // 상속이 public일 필요가 없다.
	// 복사 생성자, 복사 대입 연산자가 선언되지 않는다.
	...
	}
	```
	- 부스트 라이브러리를 보면 비슷한 noncopyable이 있다.

### 항목7: 다형성을 가진 기본 클래스에서는 소멸자를 반드시 가상 소멸자로 선언하자
- 다형성을 가진 기본 클래스에는 반드시 가상 소멸자를 선언해야 한다. 즉, 어떤 클래스가 가상 함수를 하나라도 갖고 있으면, 이 클래스의 소멸자도 가상 소멸자여야 한다.
- 기본 클래스로 설계되지 않았거나 다형성을 갖도록 설계되지 않은 클래스에는 가상 소멸자를 선언하지 말아야 한다.
	- 32비트에서는 4바이트, 64비트에서는 8바이트만큼 객체의 크기가 커진다.
	- C 등의 다른 언어로 선언된 동일한 자료구조와도 호환성이 없어진다. 가상함수 테이블 포인터를 어떻게 만들 수가 없기 때문이다.
- STL 컨테이너 타입 전부가 가상 소멸자가 없는 클래스이다. 이 클래스를 상속받아 사용할 경우 소멸자가 선언되지 않아 문제가 발생할 수 있다.

### 항목8: 예외가 소멸자를 떠나지 못하도록 붙들어 놓자
- 소멸자에서는 예외가 빠져나가면 안 된다. 만약 소멸자 안에서 호출된 함수가 예외를 던질 가능성이 있다면, 어떤 예외이든지 소멸자에서 모두 받아낸 후에 삼켜 버리던지 프로그램을 끝내던지 해야 한다.
- 어떤 클래스의 연산이 진행되다가 던진 예외에 대해 사용자가 반응해야 할 필요가 있다면, 해당 연산을 제공하는 함수는 반드시 보통의 함수(즉, 소멸자가 아닌 함수)이어야 한다.
```cpp
class DBConn
{
public:
	...
	void close() // 사용자 호출을 배려해서 새로 만든 함수
	{
		db.close();
		closed = true;
	}

	~DBConn()
	{
		if (!closed) // 사용자가 연결을 안 닫았으면 여기서 닫는다
		{
			try{
				db.close();
			}
			catch(...) // 연결을 닫다가 실패하면, 실패를 알린 후에 실행을 끝내거나 예외를 삼킨다.
			{
				close 호출이 실패했다는 로그 작성;
			}
		}
	}
private:
	DBConnection db;
	bool closed;
}
```

### 항목9: 객체 생성 및 소멸 과정 중에는 절대로 가상 함수를 호출하지 말자
- 생성자 혹은 소멸자 안에서 가상 함수를 호출하지 말자. 가상 함수라고 해도, 지금 생성중인 생성자나 소멸자에 해당되는 클래스의 파생 클래스 쪽으로는 내려가지 않기 때문이다.
	- 기본 클래스 생성 과정에서는 가상 함수가 먹히지 않는다.
	- 필요한 파생 클래스에서 기본 클래스 생성자로 '올려'주도록 만듦으로써 부족한 부분을 역으로 채울 수 있다.

### 항목10: 대입 연산자는 *this의 참조자를 반환하게 하자
- 대입 연산자는 *this의 참조자를 반환하도록 만들자
```cpp
class Widget {
public:
	...
	Widget& operator=(const Widget& rhs)
	{
		...
		return *this;
	}

	Widget& operator+=(const Widget &rhs)
	{
		...
		return *this;
	}
}
```

### 항목11: operator=에서는 자기대입에 대한 처리가 빠지지 않도록 하자
- operator=을 구현할 때, 어떤 객체가 그 자신에 대입되는 경우를 제대로 처리하도록 만들자. 원본 객체와 복사대상 객체의 주소를 비교해도 되고, 문장의 순서를 적절히 조정할 수도 있으며, temp에 복사 후 맞바꾸기 기법을 써도 된다.
- 두 개 이상의 객체에 대해 동작하는 함수가 있다면, 이 함수에 넘겨지는 객체들이 사실 같은 객체인 경우에 정확하게 동작하는지 확인해 보자.

### 항목12: 객체의 모든 부분을 빠짐없이 복사하자
- 객체 복사 함수는 주어진 객체의 모든 데이터 멤버 및 모든 기본 클래스 부분을 빠뜨리지 말고 복사해야 한다.
	- 상속 받은 경우 기본 클래스의 복사 함수를 호출하도록 만들자.
- 클래스의 복사 함수 두 개를 구현할 때, 한쪽을 이용해서 다른 쪽을 구현하려는 시도는 절대로 하지 말자. 그 대신, 공통된 동작을 제 3의 함수에다 분리해 놓고 양쪽에서 이것을 호출하게 만들어서 해결하자.

## Chapter 3: 자원 관리
### 항목13: 자원 관리에는 객체가 그만!
- 자원 누출을 막기 위해, 생성자 안에서 자원을 획득하고 소멸자에서 그것을 해제하는 RAII 객체를 사용하자.
	- RAII(Resource Acquisition Is Initialization, 자원 획득 즉 초기화): 자원 획득과 자원 관리 객체의 초기화가 바로 한 문장에서 이루어지는 것
- 일반적으로 널리 쓰이는 RAII 클래스는 tr1::shared_ptr 그리고 auto_ptr이다. 이 둘 가운데 tr1::shared_ptr이 복사 시의 동작이 직관적이기 때문에 대개 더 좋다. 반면, auto_ptr은 복사되는 객체(원본 객체)를 null로 만들어 버린다.
	- 책이 2005년에 출판되어 auto_ptr이 언급되어 있지만 auto_ptr은 C++11부터 사용 중지 권고, C++17 이후에 제거 되었고 unique_ptr로 대체되었다.
	- auto_ptr의 문제점
		- new로 생성한 단일 객체에 대해서만 메모리의 해제를 보장한다. malloc 등으로 할당한 경우 해제가 불가능하다.
		- new[]로 메모리를 할당할 경우 메모리가 정상적으로 해제되지 않을 수 있다.
		- 동일한 메모리 위치를 가리키는 객체를 2개 이상 만들면 안된다.
	- std::unique_ptr
		- 하나의 객체에 하나의 포인터만 가리킬 수 있도록 하는 스마트포인터
		- 복사 생성자를 delete로 명시적으로 삭제시켜 unique_ptr 객체를 복사하는 경우를 막는다.
		- std::move를 통해 소유권을 이전할 수 있다.
		- C++14부터 std::make_unique함수가 제공된다.
	- std::shared_ptr
		- 하나의 객체에 여러개의 포인터가 가리킬 수 있도록 하는 스마트포인터
		- 힙 메모리에 객체를 위한 메모리, 참조 카운터를 위한 메모리가 할당 된다.
		- 참조 카운터가 0이 되면 delete를 통해 메모리를 자동으로 해제한다.(delete 대신 사용자 지정 함수를 호출할 수도 있음)
	- std::weak_ptr
		- 직접적으로 자원을 할당 받을 수 없고 share_ptr이나 다른 weak_ptr의 자원을 복사 생성자나 대입 연산자를 통해서 할당 받을 수 있다.
		- 자원을 할당 받아도 참조 카운팅에 영향을 미치지 않는다.
		- 자원에 직접적으로 접근할 수 없고 lock()함수를 통해 share_ptr를 리턴받아 사용할 수 있다.
		- weak_ptr를 사용하는 이유는 share_ptr만을 사용했을 때의 circular reference(순환 참조)문제를 해결하기 위함이다.
			- 꼭 필요한 경우가 아니라면 shared_ptr로 구현하자.(lock()함수로 인한 비용 증가)

### 항목14: 자원 관리 클래스의 복사 동작에 대해 진지하게 고찰하자
- RAII 객체의 복사는 그 객체가 관리하는 자원의 복사 문제를 안고 가기 때문에, 그 자원을 어떻게 복사하느냐에 따라 RAII 객체의 복사 동작이 결정된다.
- RAII 클래스에 구현하는 일반적인 복사 동작은 복사를 금지하거나 참조 카운팅을 해주는 선으로 마무리하는 것이다. 하지만 이 외의 방법들도 가능하니 참고해 두자.
	- 복사 금지
	- 관리하고 있는 자원에 대해 참조 카운팅 수행
	- 관리하고 있는 자원을 진짜로 복사(깊은 복사)
	- 관리하고 있는 자원의 소유권을 옮김
		- 책에서는 auto_ptr를 언급하여 소유권을 옮기는 경우도 말했지만 auto_ptr가 가진 문제점으로 인해 auto_ptr가 삭제된 지금 시점에서는 좋지 않은 방법이라고 생각한다.

### 항목15: 자원 관리 클래스에서 관리되는 자원은 외부에서 접근할 수 있도록 하자
- 실제 자원을 직접 접근해야 하는 기존 API들도 많기 때문에, RAII 클래스를 만들 때는 그 클래스가 관리하는 자원을 얻을 수 있는 방법을 열어 주어야 한다.
- 자원 접근은 명시적 변환 혹은 암시적 변환을 통해 가능하다. 안전성만 따지면 명시적 변환이 대체적으로 더 낫지만, 고객 편의성을 놓고 보면 암시적 변환이 괜찮다.
	- std::shared_ptr 및 unique_ptr는 실제 포인터(의 사본)을 얻어낼 수 있는 get이라는 멤버 함수를 제공한다.

### 항목16: new 및 delete를 사용할 때는 형태를 반드시 맞추자
- new 표현식에 []를 썼으면, 대응되는 delete 표현식에도 []를 써야 한다. 마찬가지로 new 표현식에 []를 안 썼으면, 대응되는 delete 표현식에도 []를 쓰지 말아야 한다.

### 항목17: new로 생성한 객체를 스마트 포인터에 저장하는 코드는 별도의 한 문장으로 만들자
- new로 생성한 객체를 스마트 포인터로 넣는 코드는 별도의 한 문장으로 만들자. 이것이 안되어 있으면, 예외가 발생될 때 디버깅하기 힘든 자원 누출이 초래될 수 있다.
	```cpp
	processWidget(std::shared_ptr<Widget>(new Widget), priority());
	```
	- 컴파일러는 processWidget이 호출 되기 전에 매개변수 부분을 세부분으로 나눈다.
		- priority를 호출
		- new Widget을 실행
		- std::shared_ptr 생성자를 호출
	- 하지만 컴파일러마다 연산의 순서가 달라, 다음과 같은 순서일 경우 메모리 누수가 발생할 수 있다.
		1. new Widget을 실행
		2. priority를 호출 -> 예외 발생
		3. std::shared_ptr 생성자를 호출
	- 따라서 다음과 같이 Widget을 생성해서 스마트 포인터에 저장하는 코드를 별도의 문장 하나로 만드는 것이 바람직하다.
	```cpp
	std::shared_ptr<Widget> pw(new Widget);
	processWidget(pw, priority());
	```

## Chapter 4: 설계 및 선언
### 항목18: 인터페이스 설계는 제대로 쓰기엔 쉽게, 엉터리로 쓰기엔 어렵게 하자
- 좋은 인터페이스는 제대로 쓰기에 쉬우며 엉터리오 쓰기에 어렵다. 인터페이스를 만들 때는 이 특성을 지닐 수 있도록 고민하고 또 고민하자.
- 인터페이스의 올바른 사용을 이끄는 방법으로는  인터페이스 사이의 일관성 잡아주기, 그리고 기본제공 타입과의 동작 호환성 유지하기가 있다.
- 사용자의 실수를 방지하는 방법으로는 새로운 타입 만들기, 타입에 대한 연산을 제한하기, 객체의 값에 대해 제약 걸기, 자원 관리 작업을 사용자 책임으로 놓지 않기가 있다.
- std::shared_ptr은 사용자 정의 삭제자를 지원한다. 이 특징 때문에 std::shared_ptr은 교차 DLL(dynamically linked libray, 동적 링크 라이브러리) 문제를 막아 주며, 뮤텍스 등을 자동으로 잠금 해제하는 데 쓸 수 있다.

### 항목19: 클래스 설계는 타입 설계와 똑같이 취급하자
- 클래스 설계는 타입 설계이다. 새로운 타입을 정의하기 전에, 이번 항목에 나온 모든 고려사항을 빠짐없이 점검해 보자.
	- 새로 정의한 타입의 객체 생성 및 소멸은 어떻게 이루어져야 하는가?
		- 생성자 및 소멸자의 설계에 영향을 주는 부분이다. 메모리 할당 함수(operator new, operator new[], operator delete, operator delete[])를 직접 작성할 경우에는 이들 함수의 설계에도 영향을 미친다.
	- 객체 초기화는 객체 대입과 어떻게 달라야 하는가?
		- 생성자와 대입 연산자의 동작 및 둘 사이의 차이점을 결정짓는 요소이다. 초기화와 대입을 헷갈리지 않는 것이 가장 중요한데, 각각에 해당되는 함수 호출이 아예 다르기 때문이다.
	- 새로운 타입으로 만든 객체가 값에 의해 전달되는 경우에 어떤 의미를 줄 것인가?
		- 어떤 타입에 대해 '값에 의한 전달'을 구현하는 쪽은 복사 생성자이다. 기억해 두자
	- 새로운 타입이 가질 수 있는 적법한 값에 대한 제약은 무엇으로 잡을 것인가?
		- 전부는 아니지만, 클래스의 데이터 멤버의 몇 가지 조합 값만은 반드시 유효해야 한다. 이런 조합을 가리켜 클래스의 불변속성(invariant)이라고 하며, 클래스 차원에서 지켜주어야 하는 부분이다. 이 불변속성에 따라 클래스 멤버 함수 안에서 해 주어야 할 에러 점검 루틴이 좌우되는데, 특히 생성자, 대입 연산자, 각종 "쓰기(setter)" 함수는 불변속성에 많이 좌우된다. 그뿐 아니라 불변속성은 함수가 발생시키는 예외에도 영향을 미치며, 혹시나 예외 지정(exception specification)을 쓴다면 그 부분에도 영향을 준다. 
	- 기존의 클래스 상속 계통망(inheritance graph)에 맞출 것인가?
		- 이미 갖고 있는 클래스로부터 상속을 시킨다고 하면, 당연히 설계는 이들 클래스에 의해 제약을 받게 된다. 특히 멤버 함수가 가상인가 비가상인가의 여부가 가장 큰 요인이다. 만든 클래스를 다른 클래스들이 상속할 수 있게 만들자고 결정했다면, 이에 따라 멤버 함수의 가상 함수 여부가 결정 된다. 특히 소멸자가 그렇다.
	- 어떤 종류의 타입 변환을 허용할 것인가?
		- T1 타입의 객체를 T2 타입의 객체로 암시적으로(implicitly) 변환되도록 만들고 싶다면, T1 클래스에 타입 변환 함수를 하나 넣어두든가(이를테면 operator T2) 아니면 인자 한 개로 호출될 수 있는 비명시호출(non-explicit) 생성자를 T2 클래스에 넣어두어야 할 것이다. 명시적(explicit) 타입 변환만 허용하고 싶을 경우에는, 해당 변환을 맡는 별도 이름의 함수를 만들되 타입 변환 연산자 혹은 (인자 하나로 호출될 수 있는) 비명시호출 생성자는 만들지 말아야 할 것이다.
	- 어떤 연산자와 함수를 두어야 의미가 있을까?
		- 클래스 안에 선언할 함수가 바로 여기서 결정된다. 어떤 것들은 멤버 함수로 적당할 것이고, 또 몇몇은 그렇지 않을 것이다.
	- 표준 함수들 중 어떤 것을 허용하지 말 것인가?
		- private로 선언해야 하는 함수가 여기에 해당된다.
	- 새로운 타입의 멤버에 대한 접근권한을 어느 쪽에 줄 것인가?
		- 어떤 클래스 멤버를 public, protected, private 영역에 둘 것인가를 결정하는 데 도움을 주게 될 질문이다. 또한 프렌드로 만들어야 할 클래스 및 함수를 정하는 것은 물론이고 한 클래스를 다른 클래스에 중첩시켜도 되는가에 대한 결정을 내리는 데도 이 질문이 도움을 줄 것이다.
	- '선언되지 않은 인터페이스'로 무엇을 둘 것인가?
		- 새로 만들 타입이 제공할 보장이 어떤 종류일까에 대한 질문으로서, 보장할 수 있는 부분은 수행 성능 및 예외 안전성 그리고 자원 사용이다. 이들에 대해 보장하겠다고 결정한 결과는 클래스 구현에 있어서 제약으로 작용하게 된다.
	- 새로 만드는 타입이 얼마나 일반적인가?
		- 실상은 타입 하나를 정의하는 것이 아닐지도 모른다. 새로 정의하는 것이 동일 계열의 타입군(family of types) 전체일지도 모른다. 진짜 그렇다면 원하는 것은 '새로운' 클래스가 아니다. '새로운' 클래스 템플릿을 정의해야 할 것이다.
	- 정말로 꼭 필요한 타입인가?
		- 기존의 클래스에 대해 기능 몇 개가 아쉬워서 파생 클래스를 새로 뽑고 있다면, 차라리 간단하게 비멤버 함수라든지 템플릿을 몇 개 더 정의하는 편이 낫다.

### 항목20: '값에 의한 전달'보다는 '상수객체 참조자에 의한 전달' 방식을 택하는 편이 대게 낫다
- '값에 의한 전달' 보다는 '상수 객체 참조자에 의한 전달'을 선호하자. 대체적으로 효율적일 뿐만 아니라 복사손실 문제까지 막아준다.
- 이번 항목에서 다룬 법칙은 기본제공 타입 및 STL 반복자, 그리고 함수 객체 타입에는 맞지 않다. 이들에 대해서는 '값에 의한 전달'이 더 적절하다.

### 항목21: 함수에서 객체를 반환해야 할 경우에 참조자를 반환하려고 들지 말자
- 지역 스택 객체에 대한 포인터나 참조자를 반환하는 일, 혹은 힙에 할당된 객체에 대한 참조자를 반환하는 일, 또는 지역 정적 객체에 대한 포인터나 참조자를 반환하는 일은 그런 객체가 두 개 이상 필요해질 가능성이 있다면 절대로 하지 말자.

### 항목22: 데이터 멤버가 선언될 곳은 private 영역임을 명심하자
- 데이터 멤버는 private 멤버로 선언하자. 이를 통해 클래스 제작자는 문법적으로 일관성 있는 데이터 접근 통로를 제공할 수 있고, 필요에 따라서는 세밀한 접근 제어도 가능하며, 클래스의 불변속성을 강화할 수 있을 뿐 아니라, 내부 구현의 융통성도 발휘할 수 있다.
	- 데이터 멤버가 public이 아니라면, 사용자 쪽에서 어떤 객체를 접글할 수 있는 유일한 수단은 멤버 함수일 것이다. 전부 함수로 되어 있으니까 그냥 쓰면 되므로 클래스의 멤버에 접근하고 싶을 때 괄호를 붙여야 하는지 말아야 하는지 기억하는 수고를 덜어줄 수 있다.
- protected는 public보다 더 많이 '보호'받고 있는 것이 절대로 아니다.
	- 클래스에서 제거되면 깨질 수 있는 코드의 양에 반비례해서 그 데이터 멤버는 캡슐화 정도가 감소한다. public이나 protected 데이터 멤버가 제거 되었을 때, 둘다 마찬가지로 엄청나게 많은 코드가 망가질 것이다. public이나 protected나 캡슐화의 관점으로 봤을 때 오십 보 백보이므로 접근 수준은 private(캡슐화 제공)와 private가 아닌 나머지(캡슐화 없음) 이렇게 둘 뿐이라고 생각하자.

### 항목23: 멤버 함수보다는 비멤버 비프렌드 함수와 더 가까워지자
- 멤버 함수보다는 비멤버 비프렌드 함수를 자주 쓰도록 하자. 캡슐화 정도가 높아지고, 패키징 유연성도 커지며, 기능적인 확장성도 늘어난다.
	```cpp
	class WebBrowser{
	public:
		...
		void clearCache();
		void clearHistory();
		void removeCookies();
		// 멤버 함수로 구현
		void clearEverything(); // clearCache, clearHistory, removeCookies를 호출
		...
	}
	// 비멤버 함수로 구현
	void clearBrowser(WebBrowser& wb)
	{
		wb.clearCache();
		wb.clearHistory();
		wb.removeCookies();
	}
	```
	- clearBrowser를 비멤버 함수로 두고, WebBrowserStuff와 같은 네임스페이스 안에 두는 방법을 사용할 수 있다.
	```cpp
	namespace WebBrowserStuff{
		class WebBrowser {...}
		void clearBrowser(WebBrowser& wb);
		...
	}
	```
	- 함수들을 종류에 따라 여러 헤더 파일에 나누어 선언하면 컴파일 의존성에 대한 고민을 해결할 수 있다.
	- 편의 함수 전체를 여러개의 헤더파일에, 그러나 하나의 네임스페이스에 나누어 놓으면 편의 함수 집합의 확장도 손쉬워진다.
	```cpp
	// "webbrowser.h" 헤더
	// WebBrowser에 관련된 '핵심'기능들 선언
	namespace WebBrowserSturff{
		class WebBrowser {...};
		...
	}

	// "webbrowserbookmarks.h"헤더
	namespace WebBrowserStuff{
		... // 즐겨찾기 관련 편의 함수들
	}

	// "webbrowserccookies.h"헤더
	namespace WebBrowserStuff{
		... // 쿠키 관련 편의 함수들
	}
	```

### 항목24: 타입 변환이 모든 매개변수에 대해 적용되어야 한다면 비멤버 함수를 선언하자
- 어떤 함수에 들어가는 모든 매개변수(this 포인터가 가리키는 객체도 포함해서)에 대해 타입 변환을 해 줄 필요가 있다면, 그 함수는 비멤버이어야 한다.
	```cpp
	class Rational {
	public:
		Rational(int numerator = 0, int denominator = 1);
		int numerator() const;
		int denominator() const;
		const Rational operator*(const Rational& rhs) const;
	private:
		...
	}

	Rational oneEighth(1, 8);
	Rational oneHalf(1, 2);

	Rational result = oneHalf * oneEighth;
	result = result * oneEighth;

	result = oneHalf * 2;	// oneHalf.operator*(2)
	result = 2 * oneHalf;   // 2.operator*(oneHalf) -> Error
	```
	```cpp
	class Rational {
		...
	};
	// 비멤버 함수로 선언
	const Rational operator*(const Rational& lhs, const Rational& rhs)
	{
		return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator());
	}

	Rational oneFourth(1, 4);
	Rational result;

	result = oneFourth * 2;
	result = 2 * oneFourth;    // Not Error
	```

### 항목25: 예외를 던지지 않는 swap에 대한 지원도 생각해 보자
- std::swap이 어떤 타입에 대해 느리게 동작할 여지가 있다면 swap 멤버 함수를 제공하자. 이 멤버 swap은 예외를 던지지 않도록 만들자.
- 멤버 swap을 제공했으면, 이 멤버를 호출하는 비멤버 swap도 제공하자. 클래스(템플릿이 아닌)에 대해서는, std::swap도 특수해 두자.
- 사용자 입장에서 swap을 호출할 때는, std::swap에 대한 using 선언을 넣어 준 후에 네임스페이스 한정 없이 swap을 호출하자.
- 사용자 정의 타입에 대한 std 템플릿을 완전 특수화하는 것은 가능하다. 그러나 std에 어떤 것이라도 새로 '추가'하려고 들지 말자.

## Chapter 5: 구현
### 항목26: 변수 정의는 늦출 수 있는 데까지 늦추는 근성을 발휘하자
- 변수 정의는 늦출 수 있을 때까지 늦추자. 프로그램이 더 깔끔해지며 효율도 좋아진다.
	- 다음과 같은 경우 쓸데없는 기본생성자 호출과 소멸자 호출을 막을 수 있다.
	```cpp
	std::string encryptPassword(const std::string& password)
	{
		// std::string encrypted; 기존위치

		if (password.length() < MinimumPasswordLength)
		{
			throw logic_error("Password is too short")
		}
		// 효율 개선
		std::string encrypted(password);

		encrypt(encrypted);
		return encrypted;
	}
	```
	- A
		```cpp
		Widget w;
		for (int i = 0; i < n; i++)
		{
			w = i;
		}
		```
	- B
		```cpp
		for (int i = 0; i < n; i++)
		{
			Widget w(i);
		}
		```
	- A 방법: 생성자 1번, 소멸자 1번, 대입 n번
	- B 방법: 생성자 n번, 소멸자 n번
	- 1.대입이 생성자-소멸자 쌍보다 비용이 덜 들고 2.전체 코드에서 수행 성능에 민감한 부분을 건드리는중이라고 생각하지 않는다면, 앞뒤 볼 것 없이 B 방법으로 가는 것이 좋다.

### 항목27: 캐스팅은 절약, 또 절약! 잊지 말자
- 다른 방법이 가능하다면 캐스팅은 피하자. 특히 수행 성능에 민감한 코드에서 dynamic_cast는 몇 번이고 다시 생각하자. 설계 중에 캐스팅이 필요해졌다면, 캐스팅을 쓰지 않는 다른 방법을 시도해 보자.
- 캐스팅이 어쩔 수 없이 필요하다면, 함수 안에 숨길 수 있도록 해보자. 이렇게 하면 최소한 사용자는 자신의 코드에 캐스팅을 넣지 않고 이 함수를 호출할 수 있게 된다.
- 구형 스타일의 캐스트를 쓰려거든 C++ 스타일의 캐스트를 선호하자. 발견하기도 쉽고, 설계자가 어떤 역할을 의도했는지가 더 자세하게 드러난다.
	- const_cast\<T>(표현식)
		- 객체의 상수성을 없애는 용도로 사용된다. 이런 기능을 가진 C++ 스타일의 캐스트는 이것밖에 없다.
	- dynamic_cast\<T>(표현식)
		- 이른바 '안전한 다운캐스팅'을 할 때 사용하는 연산자이다. 즉, 주어진 객체가 어떤 클래스 상속 계통에 속한 특정 타입인지 아닌지를 결정하는 작업에 쓰인다. 구형 스타일의 캐스트 문법으로는 흉내조차도 낼 수 없는 유일한 캐스트이기도 하다. 덤으로, 신경 쓰일 정도로 런타임 비용이 높은 캐스트 연산자로도 유일하다.
	- reinterpret_cast\<T>(표현식)
		- 포인터를 int로 바꾸는 등의 하부 수준 캐스팅을 위해 만들어진 연산자로서, 이것의 적용 결과는 구현환경에 의존적이다(이식성이 없다). 이런 캐스트는 하부 수준 코드 외에는 거의 없어야 한다. 이 책에서도 원시 메모리용 디버깅 할당자를 작성하는 방법에 대해 의견을 제시할 때 딱 한번 썼다고 한다.
	- static_cast\<T>(표현식)
		- 암시적 변환[비상수 객체를 상수 객체로 바꾸거나, int를 double로 바꾸는 등의 변환]을 강제로 진행할 때 사용한다. 흔히들 이루어지는 타입 변환을 거꾸로 수행하는 용도(void*를 일반 타입의 포인터로 바꾸거나, 기본 클래스의 포인터를 파생 클래스의 포인터로 바꾸는 등)로도 쓰인다. 물론 상수 객체를 비상수 객체로 캐스팅하는 데 이것을 쓸 수는 없다.(const_cast 연산자밖에 안 됨)
	- 다음과 같은 경우, 두 포인터의 값이 같지 않을 수 있다.
		```cpp
		class Base {...};
		class Derived: public Base {...};
		Derived d;
		Base *pb = &d;
		```
		- 포인터의 변위(offset)을 Derived* 포인터에 적용하여 실제의 Base* 포인터 값을 구하는 동작이 바로 런타임에 이루어진다.
		- 객체 하나가 가질 수 있는 주소가 오직 한 개가 아니라 그 이상이 될 수 있음을(Base* 포인터로 가리킬 때의 주소, Dreived* 포인터로 가리킬 때의 주소) 보여주는 사례이다.