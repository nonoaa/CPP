# Effective Modern C++

## 1장 형식 연역
### 항목 1: 템플릿 형식 연역 규칙을 숙지하라
- template T와 ParamType T의 형식이 달라질 수 있으니 잘 숙지해야 한다. 특히 const와 &가 사용된 경우 그러하다.
- 기억해 둘 사항들
    - 템플릿 형식 연역 도중에 참조 형식의 인수들은 비참조로 취급된다. 즉, 참조성이 무시된다.
    - 보편 참조 매개변수에 대한 형식 연역 과정에서 왼값 인수들은 특별하게 취급된다.
    - 값 전달 방식의 매개변수에 대한 형식 연역 과정에서 const 또는 volatile(또는 그 둘 다인) 인수는 비 const, 비 volatile 인수로 취급된다.
    - 템플릿 형식 연역 과정에서 배열이나 함수 이름에 해당하는 인수는 포인터로 붕괴한다. 단, 그런 인수가 참조를 초기화하는 데 쓰이는 경우에는 포인터로 붕괴하지 않는다.

### 항목 2: 항목 2: auto의 형식 연역 규칙을 숙지하라
- 기본적으로 템플릿과 동일하다. 단, auto x = { 1 } 형식의 값은 std::initializer_list\<int\>가 된다.
- 기억해 둘 사항들
    - auto 형식 연역은 대체로 템플릿 형식 연역과 같지만, auto 형식 연역은 중괄호 초기치가 std::initializer_list 를 나타낸다고 가정하는 반면, 템플릿 형식 연역은 그렇지 않다는 차이가 있다.
    - 함수의 반환 형식이나 람다 매개변수에 쓰인 auto 에 대해서는 auto 형식 연역이 아니라 템플릿 형식 연역이 적용된다.


### 항목 3: decltype의 작동 방식을 숙지하라
- template에서 decltype으로 인자와 동일한 형태를 반환하는 등의 방법으로 사용을 할 떄에는 좀 더 주의해야 한다.
- 기억해 둘 사항들
    - decltype 은 항상 변수나 표현식의 형식을 아무 수정 없이 보고한다.
    - decltype 은 형식이 T 이고 이름이 아닌 왼값 표현식에 대해서는 항상 T& 형식을 보고한다.
    - C++14 는 decltype(auto) 를 지원한다. decltype(auto)는 auto 처럼 초기치로부터 형식을 연역하지만, 그 형식 연역 과정에서 decltype 의 규칙들을 적용한다.

### 항목 4 : 연역된 형식을 파악하는 방법을 알아두라
- IDE나 std::type_info::name이 항상 완벽하지는 않다. boost::typeindex::type_id_with_cvr은 정확하긴 하지만 내가 잘 알고있는 것이 최고다.
- 기억해 둘 사항들
    - 컴파일러가 연역하는 형식을 IDE 편집기나 컴파일러 오류 메시지, Boost TypeIndex 라이브러리를 이용해서 파악할 수 있는 경우가 많다.
    - 일부 도구의 결과는 유용하지도 않고 부정확할 수 있으므로, C++ 의 형식 연역 규칙들을 제대로 이해하는 것은 여전히 필요한 일이다.

## 2장 auto
### 항목 5: 명시적 형식 선언보다는 auto를 선호하라
- 초기화 필수, 불필요한 복사 방지, 클로저 저장, 암묵적 변환 방지, 유지보수의 편리함 등의 이유로 auto를 사용하는 것이 좋다.
- 기억해 둘 사항들
    - auto 변수는 반드시 초기화 해야 하며, 이식성 또는 효율성 문제를 유발할 수 있는 형식 불일치가 발생하는 경우가 거의 없으며, 대체로 변수의 형식을 명시적으로 지정할 때보다 타자량도 더 적다.
    - auto 로 형식을 지정한 변수는 항목 2 와 항목 6 에서 설명한 문제점들을 겪을 수 있다.

### 항목 6 : auto 가 원치 않은 형식으로 연역될 때는 명시적 형식의 초기치를 사용하라
- std::vector의 [] 접근 같은 대리자 클래스를 사용할 경우엔 static_cast으로 명시적으로 바꿔서 auto에 대입한다.
- 기억해 둘 사항들
    - "보이지 않는" 대리자 형식 때문에 auto 가 초기화 표현식의 형식을 "잘못" 연역할 수 있다.
    - 형식 명시 초기치 관용구는 auto 가 원하는 형식을 연역하도록 강제한다.

## 3장 현대적 C++에 적용하기
### 항목 7: 객체 생성 시 괄호(())와 중괄호({})를 구분하라
- 중괄호 초기화는 좋긴 하지만 std::initializer_list 매개변수가 있는 경우엔 가능하면 항상 이걸 선호하므로 주의가 필요하다. 선택과 스타일의 영역.
- 기억해 둘 사항들
    - 중괄호 초기화는 가장 광범위하게 적용할 수 있는 초기화 구문이며, 좁히기 변환을 방지하며, C++ 의 가장 성가신 구문 해석에서 자유롭다.
    - 생성자 오버로딩 해소 과정에서 중괄호 초기화는 가능한 한 std::initializer_list 매개변수가 있는 생성자와 부합한다.
    - 괄호와 중괄호의 선택이 의미 있는 차이를 만드는 예는 인수 두 개로 std::vector<수치 형식> 을 생성하는 것이다.
    - 템플릿 안에서 객체를 생성할 때 괄호를 사용할 것인지 중괄호를 사용할 것인지 선택하기가 어려울 수 있다.

### 항목8: 0과 NULL보다 nullptr를 선호하라
- 템플릿에 0이나 NULL을 넘기면 int 타입으로 인식해 문제가 생길 수 있다.
- 기억해 둘 사항들
    - 0 과 NULL 보다 nullptr 를 선호하라.
    - 정수 형식과 포인터 형식에 대한 오버로딩을 피하라.

### 항목 9: typedef보다 별칭 선언을 선호하라
- using은 typedef와 동일하게 동작하지만 템플릿을 작성하는 상황에 유리하다.
- 기억해 둘 사항들
    - typedef 은 템플릿화를 지원하지 않지만, using 은 지원한다.
    - 별칭 템플릿에서는 "::type" 접미어를 붙일 필요가 없다. 템플릿 안에서 typedef 을 지칭할 때에는 "typename" 접두사를 붙여야 하는 경우가 많다.
    - C++14 는 C++11 의 모든 형식 특질 변환에 대한 using 들을 제공한다.

### 항목 10: 범위 없는 enum보다 범위 있는 enum을 선호하라
- enum class는 전방 선언, 이름 오염, 암묵적 변환 방지 등의 장점이 있다.
- 기억해 둘 사항들
    - C++98 스타일의 enum 을 이제는 범위 없는 enum 이라고 부른다.
    - 범위 있는 enum 의 열거자들은 그 안에서만 보인다. 이 열거자들은 오직 캐스팅을 통해서만 다른 형식으로 변환된다.
    - 범위 있는 enum 과 범위 없는 enum 모두 바탕 형식 지정을 지원한다. 범위 있는 enum 의 기본 바탕 형식은 int 이다. 범위 없는 enum 에는 기본 바탕 형식이 없다.
    - 범위 있는 enum 은 항상 전방 선언이 가능하다. 범위 없는 enum 은 해당 선언에 바탕 형식을 지정하는 경우에만 전방 선언이 가능하다.

### 항목 11: 정의되지 않은 비공개 함수보다 삭제된 함수를 선호하라
- 예전에 사용하던 private 선언 후 구현하지 않는 방법은 = delete가 없어서 그랬던 것.
- 기억해 둘 사항들
    - 정의되지 않은 비공개 함수보다 삭제된 함수를 선호하라.
    - 비멤버 함수와 템플릿 인스턴스를 비롯한 그 어떤 함수도 삭제할 수 있다.

### 항목 12: 재정의 함수들을 override로 선언하라
- 재정의 과정에서 실수 하거나 의도와 다르게 구현하는 것을 override와 final로 방지할 수 있다.
- 기억해 둘 사항들
    - 재정의 함수는 override 로 선언하라.
    - 멤버 함수 참조 한정사(reference qualifier)를 이용하면 멤버 함수가 호출되는 객체(*this)의 왼값 버전과 오른값 버전을 다른 방식으로 처리할 수 있다.

### 항목 13: iterator 보다 const_iterator를 선호하라
- C++11에서는 const_iterator 사용이 쉬워졌기 때문에 안 쓸 이유가 없다.
- 기억해 둘 사항들
    - iterator 보다 const_iterator 를 선호하라.
    - 최대한 일반적인 코드에서는 begin, end, rbegin 등의 비멤버 버전들을 해당 멤버 함수들보다 선호하라.

### 항목 14: 예외를 방출하지 않을 함수는 noexcept로 선언하라
- 이동, swap 등에서 noexcept를 사용하면 컴파일러 최적화 여지가 크다. 단, 한 번 사용하면 없애기 어려우므로 신중해야 한다.
- 기억해 둘 사항들
    - noexcept 는 함수의 인터페이스의 일부이다. 이는 호출자가 noexcept 여부에 의존할 수 있음을 뜻한다.
    - noexcept 함수는 비 noexcept 함수보다 최적화의 여지가 크다.
    - noexcept 는 이동 연산들과 swap, 메모리 해제 함수들, 그리고 소멸자들에 특히나 유용하다.
    - 대부분의 함수는 noexcept 가 아니라 예외에 중립적이다.

### 항목 15: 가능하면 항상 constexpr을 사용하라
- 객체와 함수가 다르게 동작하는 것을 알고, 계속 constexpr을 유지할 수 있다면 사용하는 것이 항상 좋다.
- 기억해 둘 사항들
    - constexpr 객체는 const 이며, 컴파일 도중에 알려지는 값들로 초기화된다.
    - constexpr 함수는 그 값이 컴파일 도중에 알려지는 인수들로 호출하는 경우에는 컴파일 시점 결과를 산출한다.
    - constexpr 객체나 함수는 비constexpr 객체나 함수보다 광범위한 문맥에서 사용할 수 있다.
    - constexpr 은 객체나 함수의 인터페이스의 일부이다.

### 항목 16: const 멤버 함수를 스레드에 안전하게 작성하라
- const 멤버 함수에서 의도적으로 mutable 멤버 변수를 조작할 경우 atomic, mutex 등을 이용해 스레드 안전하게 작성해야 한다.
- 기억해 둘 사항들
    - 동시적 문맥에서 쓰이지 않을 것이 확실한 경우가 아니라면, const 멤버 함수는 스레드에 안전하게 작성하라.
    - std::atomic 변수는 mutex 에 비해 성능상의 이점이 있지만, 하나의 변수 또는 메모리 장소를 다룰 때에만 적합하다.

### 항목 17: 특수 멤버 함수들의 자동 작성 조건을 숙지하라
- 소멸자, 복사, 이동 관련 함수 중 하나라도 사용자가 정의하면 이동 생성/대입은 자동 생성되지 않으므로 필요하면 = default를 통해 명시해 주는 것이 성능 하락을 방지할 수 있다.
- 기억해 둘 사항들
    - 컴파일러가 스스로 작성할 수 있는 멤버 함수들, 즉 기본 생성자와 소멸자, 복사 연산들, 이동 연산들을 가리켜 특수 멤버 함수라고 한다.
    - 이동 연산들은 이동 연산들이나 복사 연산들, 소멸자가 명시적으로 선언되어 있지 않은 클래스에 대해서만 자동으로 작성된다.
    - 복사 생성자는 복사 생성자가 명시적으로 선언되어 있지 않은 클래스에 대해서만 자동으로 작성되며, 만일 이동 연산이 하나라도 선언되어 있으면 삭제된다. 복사 배정 연산자는 복사 배정 연산자가 명시적으로 선언되어 있지 않은 클래스에 대해서만 자동으로 작성되며, 만일 이동 연산이 하나라도 선언되어 있으면 삭제된다. 소멸자가 명시적으로 선언된 클래스에서 복사 연산들이 자동으로 작성되는 기능은 비권장이다.
    - 멤버 함수 템플릿 때문에 특수 멤버 함수의 자동 작성이 금지되는 경우는 전혀 없다.