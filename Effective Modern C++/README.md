# Effective Modern C++

## 1장 형식 연역
### 항목 1: 템플릿 형식 연역 규칙을 숙지하라
- template T와 ParamType T의 형식이 달라질 수 있으니 잘 숙지해야 한다. 특히 const와 &가 사용된 경우 그러하다.
- 기억해 둘 사항들
    - 템플릿 형식 연역 도중에 참조 형식의 인수들은 비참조로 취급된다. 즉, 참조성이 무시된다.
    - 보편 참조 매개변수에 대한 형식 연역 과정에서 왼값 인수들은 특별하게 취급된다.
    - 값 전달 방식의 매개변수에 대한 형식 연역 과정에서 const 또는 volatile(또는 그 둘 다인) 인수는 비 const, 비 volatile 인수로 취급된다.
    - 템플릿 형식 연역 과정에서 배열이나 함수 이름에 해당하는 인수는 포인터로 붕괴한다. 단, 그런 인수가 참조를 초기화하는 데 쓰이는 경우에는 포인터로 붕괴하지 않는다.

### 항목 2: 항목 2: auto의 형식 연역 규칙을 숙지하라
- 기본적으로 템플릿과 동일하다. 단, auto x = { 1 } 형식의 값은 std::initializer_list\<int\>가 된다.
- 기억해 둘 사항들
    - auto 형식 연역은 대체로 템플릿 형식 연역과 같지만, auto 형식 연역은 중괄호 초기치가 std::initializer_list 를 나타낸다고 가정하는 반면, 템플릿 형식 연역은 그렇지 않다는 차이가 있다.
    - 함수의 반환 형식이나 람다 매개변수에 쓰인 auto 에 대해서는 auto 형식 연역이 아니라 템플릿 형식 연역이 적용된다.


### 항목 3: decltype의 작동 방식을 숙지하라
- template에서 decltype으로 인자와 동일한 형태를 반환하는 등의 방법으로 사용을 할 떄에는 좀 더 주의해야 한다.
- 기억해 둘 사항들
    - decltype 은 항상 변수나 표현식의 형식을 아무 수정 없이 보고한다.
    - decltype 은 형식이 T 이고 이름이 아닌 왼값 표현식에 대해서는 항상 T& 형식을 보고한다.
    - C++14 는 decltype(auto) 를 지원한다. decltype(auto)는 auto 처럼 초기치로부터 형식을 연역하지만, 그 형식 연역 과정에서 decltype 의 규칙들을 적용한다.

### 항목 4 : 연역된 형식을 파악하는 방법을 알아두라
- IDE나 std::type_info::name이 항상 완벽하지는 않다. boost::typeindex::type_id_with_cvr은 정확하긴 하지만 내가 잘 알고있는 것이 최고다.
- 기억해 둘 사항들
    - 컴파일러가 연역하는 형식을 IDE 편집기나 컴파일러 오류 메시지, Boost TypeIndex 라이브러리를 이용해서 파악할 수 있는 경우가 많다.
    - 일부 도구의 결과는 유용하지도 않고 부정확할 수 있으므로, C++ 의 형식 연역 규칙들을 제대로 이해하는 것은 여전히 필요한 일이다.

## 2장 auto
### 항목 5: 명시적 형식 선언보다는 auto를 선호하라
- 초기화 필수, 불필요한 복사 방지, 클로저 저장, 암묵적 변환 방지, 유지보수의 편리함 등의 이유로 auto를 사용하는 것이 좋다.
- 기억해 둘 사항들
    - auto 변수는 반드시 초기화 해야 하며, 이식성 또는 효율성 문제를 유발할 수 있는 형식 불일치가 발생하는 경우가 거의 없으며, 대체로 변수의 형식을 명시적으로 지정할 때보다 타자량도 더 적다.
    - auto 로 형식을 지정한 변수는 항목 2 와 항목 6 에서 설명한 문제점들을 겪을 수 있다.

### 항목 6 : auto 가 원치 않은 형식으로 연역될 때는 명시적 형식의 초기치를 사용하라
- std::vector의 [] 접근 같은 대리자 클래스를 사용할 경우엔 static_cast으로 명시적으로 바꿔서 auto에 대입한다.
- 기억해 둘 사항들
    - "보이지 않는" 대리자 형식 때문에 auto 가 초기화 표현식의 형식을 "잘못" 연역할 수 있다.
    - 형식 명시 초기치 관용구는 auto 가 원하는 형식을 연역하도록 강제한다.

## 3장 현대적 C++에 적용하기
### 항목 7: 객체 생성 시 괄호(())와 중괄호({})를 구분하라
- 중괄호 초기화는 좋긴 하지만 std::initializer_list 매개변수가 있는 경우엔 가능하면 항상 이걸 선호하므로 주의가 필요하다. 선택과 스타일의 영역.
- 기억해 둘 사항들
    - 중괄호 초기화는 가장 광범위하게 적용할 수 있는 초기화 구문이며, 좁히기 변환을 방지하며, C++ 의 가장 성가신 구문 해석에서 자유롭다.
    - 생성자 오버로딩 해소 과정에서 중괄호 초기화는 가능한 한 std::initializer_list 매개변수가 있는 생성자와 부합한다.
    - 괄호와 중괄호의 선택이 의미 있는 차이를 만드는 예는 인수 두 개로 std::vector<수치 형식> 을 생성하는 것이다.
    - 템플릿 안에서 객체를 생성할 때 괄호를 사용할 것인지 중괄호를 사용할 것인지 선택하기가 어려울 수 있다.

### 항목8: 0과 NULL보다 nullptr를 선호하라
- 템플릿에 0이나 NULL을 넘기면 int 타입으로 인식해 문제가 생길 수 있다.
- 기억해 둘 사항들
    - 0 과 NULL 보다 nullptr 를 선호하라.
    - 정수 형식과 포인터 형식에 대한 오버로딩을 피하라.

### 항목 9: typedef보다 별칭 선언을 선호하라
- using은 typedef와 동일하게 동작하지만 템플릿을 작성하는 상황에 유리하다.
- 기억해 둘 사항들
    - typedef 은 템플릿화를 지원하지 않지만, using 은 지원한다.
    - 별칭 템플릿에서는 "::type" 접미어를 붙일 필요가 없다. 템플릿 안에서 typedef 을 지칭할 때에는 "typename" 접두사를 붙여야 하는 경우가 많다.
    - C++14 는 C++11 의 모든 형식 특질 변환에 대한 using 들을 제공한다.

### 항목 10: 범위 없는 enum보다 범위 있는 enum을 선호하라
- enum class는 전방 선언, 이름 오염, 암묵적 변환 방지 등의 장점이 있다.
- 기억해 둘 사항들
    - C++98 스타일의 enum 을 이제는 범위 없는 enum 이라고 부른다.
    - 범위 있는 enum 의 열거자들은 그 안에서만 보인다. 이 열거자들은 오직 캐스팅을 통해서만 다른 형식으로 변환된다.
    - 범위 있는 enum 과 범위 없는 enum 모두 바탕 형식 지정을 지원한다. 범위 있는 enum 의 기본 바탕 형식은 int 이다. 범위 없는 enum 에는 기본 바탕 형식이 없다.
    - 범위 있는 enum 은 항상 전방 선언이 가능하다. 범위 없는 enum 은 해당 선언에 바탕 형식을 지정하는 경우에만 전방 선언이 가능하다.

### 항목 11: 정의되지 않은 비공개 함수보다 삭제된 함수를 선호하라
- 예전에 사용하던 private 선언 후 구현하지 않는 방법은 = delete가 없어서 그랬던 것.
- 기억해 둘 사항들
    - 정의되지 않은 비공개 함수보다 삭제된 함수를 선호하라.
    - 비멤버 함수와 템플릿 인스턴스를 비롯한 그 어떤 함수도 삭제할 수 있다.

### 항목 12: 재정의 함수들을 override로 선언하라
- 재정의 과정에서 실수 하거나 의도와 다르게 구현하는 것을 override와 final로 방지할 수 있다.
- 기억해 둘 사항들
    - 재정의 함수는 override 로 선언하라.
    - 멤버 함수 참조 한정사(reference qualifier)를 이용하면 멤버 함수가 호출되는 객체(*this)의 왼값 버전과 오른값 버전을 다른 방식으로 처리할 수 있다.

### 항목 13: iterator 보다 const_iterator를 선호하라
- C++11에서는 const_iterator 사용이 쉬워졌기 때문에 안 쓸 이유가 없다.
- 기억해 둘 사항들
    - iterator 보다 const_iterator 를 선호하라.
    - 최대한 일반적인 코드에서는 begin, end, rbegin 등의 비멤버 버전들을 해당 멤버 함수들보다 선호하라.

### 항목 14: 예외를 방출하지 않을 함수는 noexcept로 선언하라
- 이동, swap 등에서 noexcept를 사용하면 컴파일러 최적화 여지가 크다. 단, 한 번 사용하면 없애기 어려우므로 신중해야 한다.
- 기억해 둘 사항들
    - noexcept 는 함수의 인터페이스의 일부이다. 이는 호출자가 noexcept 여부에 의존할 수 있음을 뜻한다.
    - noexcept 함수는 비 noexcept 함수보다 최적화의 여지가 크다.
    - noexcept 는 이동 연산들과 swap, 메모리 해제 함수들, 그리고 소멸자들에 특히나 유용하다.
    - 대부분의 함수는 noexcept 가 아니라 예외에 중립적이다.

### 항목 15: 가능하면 항상 constexpr을 사용하라
- 객체와 함수가 다르게 동작하는 것을 알고, 계속 constexpr을 유지할 수 있다면 사용하는 것이 항상 좋다.
- 기억해 둘 사항들
    - constexpr 객체는 const 이며, 컴파일 도중에 알려지는 값들로 초기화된다.
    - constexpr 함수는 그 값이 컴파일 도중에 알려지는 인수들로 호출하는 경우에는 컴파일 시점 결과를 산출한다.
    - constexpr 객체나 함수는 비constexpr 객체나 함수보다 광범위한 문맥에서 사용할 수 있다.
    - constexpr 은 객체나 함수의 인터페이스의 일부이다.

### 항목 16: const 멤버 함수를 스레드에 안전하게 작성하라
- const 멤버 함수에서 의도적으로 mutable 멤버 변수를 조작할 경우 atomic, mutex 등을 이용해 스레드 안전하게 작성해야 한다.
- 기억해 둘 사항들
    - 동시적 문맥에서 쓰이지 않을 것이 확실한 경우가 아니라면, const 멤버 함수는 스레드에 안전하게 작성하라.
    - std::atomic 변수는 mutex 에 비해 성능상의 이점이 있지만, 하나의 변수 또는 메모리 장소를 다룰 때에만 적합하다.

### 항목 17: 특수 멤버 함수들의 자동 작성 조건을 숙지하라
- 소멸자, 복사, 이동 관련 함수 중 하나라도 사용자가 정의하면 이동 생성/대입은 자동 생성되지 않으므로 필요하면 = default를 통해 명시해 주는 것이 성능 하락을 방지할 수 있다.
- 기억해 둘 사항들
    - 컴파일러가 스스로 작성할 수 있는 멤버 함수들, 즉 기본 생성자와 소멸자, 복사 연산들, 이동 연산들을 가리켜 특수 멤버 함수라고 한다.
    - 이동 연산들은 이동 연산들이나 복사 연산들, 소멸자가 명시적으로 선언되어 있지 않은 클래스에 대해서만 자동으로 작성된다.
    - 복사 생성자는 복사 생성자가 명시적으로 선언되어 있지 않은 클래스에 대해서만 자동으로 작성되며, 만일 이동 연산이 하나라도 선언되어 있으면 삭제된다. 복사 배정 연산자는 복사 배정 연산자가 명시적으로 선언되어 있지 않은 클래스에 대해서만 자동으로 작성되며, 만일 이동 연산이 하나라도 선언되어 있으면 삭제된다. 소멸자가 명시적으로 선언된 클래스에서 복사 연산들이 자동으로 작성되는 기능은 비권장이다.
    - 멤버 함수 템플릿 때문에 특수 멤버 함수의 자동 작성이 금지되는 경우는 전혀 없다.

## 4장 똑똑한 포인터
### 항목 18: 소유권 독점 자원의 관리에는 std::unique_ptr를 사용하라
- std::unique_ptr에 커스텀 삭제자를 지정하여 delete 함수의 동작을 다르게 할 수도 있다.
- 커스텀 삭제자로 함수 포인터를 지정한 경우에는 std::unique_ptr의 크기가 1워드에서 2워드로 증가한다.
- 삭제자가 함수 객체일 때에는 std::unique_ptr의 크기가 그 함수 객체에 저장된 상태의 크기만큼 증가한다. 상태 없는 함수 객체(갈무리 없는 람다 표현식)의 경우에는 크기 변화가 없다. 
- 기억해 둘 사항들
    - std::unique_ptr 는 독점 소유권 의미론을 가진 자원의 관리를 위한, 작고 빠른 이동 전용 똑똑한 포인터이다.
    - 기본적으로 자원 파괴는 delete 를 통해 일어나나, 커스텀 삭제자를 지정할 수 있다. 상태 있는 삭제자나 함수 포인터를 사용하면 std::unique_ptr 객체의 크기가 커진다.
    - std::unique_ptr 를 std::shared_ptr 로 손쉽게 변환할 수 있다.

### 항목 19: 소유권 공유 자원의 관리에는 std::shared_ptr를 사용하라
- std::shared_ptr의 크기는 생 포인터의 두 배이다. 자원을 가리키는 생 포인터 뿐만 아니라 자원의 참조 횟수를 가리키는 생 포인터도 저장해야 하기 때문이다.
- std::shared_ptr의 크기는 항상 포인터 두 개 분량이기 때문에 삭제자를 지정하더라도 크기가 증가하지 않는다.
- 기억해 둘 사항들
    - std::shared_ptr 는 임의의 공유 자원의 수명을 편리하게(쓰레기 수거에 맡길 때만큼이나) 관리할 수 있는 수단을 제공한다.
    - 대체로 std::shared_ptr 객체는 그 크기가 std::shared_ptr 객체의 두 배이며, 제어 블록에 관련된 추가 부담을 유발하며, 원자적 참조 횟수 조작을 요구한다.
    - 자원은 기본적으로 delete 를 통해 파괴되나, 커스텀 삭제자도 지원된다. 삭제자의 형식은 std::shared_ptr 의 형식에 아무런 영향도 미치지 않는다.
    - 생 포인터 형식의 변수로부터 std::shared_ptr 를 생성하는 일은 피해야 한다.

### 항목 20: std::shared_ptr 처럼 작동하되 대상을 잃을 수도 있는 포인터가 필요하면 std::weak_ptr 를 사용하라
- 기억해 둘 사항들
    - std::shared_ptr 처럼 작동하되 대상을 잃을 수도 있는 포인터가 필요하면 std::weak_ptr 를 사용하라
    - std::weak_ptr 의 잠재적인 용도로는 캐싱, 관찰자 목록, 그리고 std::shared_ptr 순환 고리 방지가 있다.

### 항목 21: new 를 직접 사용하는 것보다 std::make_unique 와 std::make_shared 를 선호하라
- 코드, 속도, 메모리 사용량 면에서 효율적이다. 단, 커스텀 삭제자를 지정하거나 T의 크기가 매우 커서 weak_ptr의 사용이 끝나기까지 메모리를 붙잡고 있는게 싫은 경우엔 new를 사용하는게 더 합당할 수 있다.
- 기억해 둘 사항들
    - new 의 직접 사용에 비해, make 함수를 사용하면 소스 코드 중복의 여지가 없어지고, 예외 안전성이 향상되고, std::make_shared 와 std::allocate_shared 의 경우 더 작고 빠른 코드가 산출된다.
    - make 함수의 사용이 불가능 또는 부적합한 경우로는 커스텀 삭제자를 지정해야 하는 경우와 중괄호 초기치를 전달해야 하는 경우가 있다.
    - std::shared_ptr 에 대해서는 make 함수가 부적합한 경우가 더 있는데, 두 가지 예를 들자면 (1) 커스텀 메모리 관리 기능을 가진 클래스를 다루는 경우와 (2) 메모리가 넉넉하지 않은 시스템에서 큰 객체를 자주 다루어야 하고 std::weak_ptr 들이 해당 std::shared_ptr 들보다 더 오래 살아남는 경우이다.

### 항목 22: Pimpl 관용구를 사용할 때에는 특수 멤버 함수들을 구현 파일에서 정의하라
- unique_ptr을 사용할 경우엔 삭제자가 정의에 포함되기 때문에, 컴파일 시점에서 완전한 클래스여야 한다. 따라서 cpp 정의부로 특수 멤버 함수들의 구현을 옮겨 컴파일 에러를 피해야 한다.
- 기억해 둘 사항들
   - Pimpl 관용구는 클래스 구현과 클래스 클라이언트 사이의 컴파일 의존성을 줄임으로써 빌드 시간을 감소한다.
    - std::unique_ptr 형식의 pImpl 포인터를 사용할 때에는 특수 멤버 함수들을 클래스 헤더에 선언하고 구현 파일에서 구현해야 한다. 컴파일러가 기본으로 작성하는 함수 구현들이 사용하기에 적합한 경우에도 그렇게 해야 한다.
    - 위의 조언은 std::unique_ptr 에 적용될 뿐, std::shared_ptr 에는 적용되지 않는다.

## 5장 오른값 참조, 이동 의미론, 완벽 전달
### 항목 23: std::move와 std::forward를 숙지하라
- 기억해 둘 사항들
    - std::move 는 오른값으로의 무조건 캐스팅을 수행한다. std::move 자체는 아무것도 이동하지 않는다.
    - std::forward 는 주어진 인수가 오른값에 묶인 경우에만 그것을 오른값으로 캐스팅한다.
    - std::move 와 std::forward 둘 다, 실행 시점에서는 아무 일도 하지 않는다.

### 항목 24 : 보편 참조와 오른값 참조를 구별하라
- 기억해 둘 사항들
    - 함수 템플릿 매개변수의 형식이 T&& 형태이고 T 가 연역된다면, 또는 객체를 auto&& 로 선언한다면, 그 매개변수나 객체는 보편 참조이다.
    - 형식 선언의 형태가 정확히 형식&& 가 아니면, 또는 형식 연역이 일어나지 않으면, 형식&& 는 오른값 참조를 뜻한다.
    - 오른값으로 초기화되는 보편 참조는 오른값 참조에 해당한다. 왼값으로 초기화되는 보편 참조는 왼값 참조에 해당한다.

### 항목 25 : 오른값 참조에는 std::move 를, 보편 참조에는 std::forward 를 사용하라
- 기억해 둘 사항들
    - 오른값 참조나 보편 참조가 마지막으로 쓰이는 지점에서, 오른값 참조에는 std::move 를, 보편 참조에는 std::forward 를 적용하라.
    - 결과를 값 전달 방식으로 돌려주는 함수가 오른값 참조나 보편 참조를 돌려줄 때에도 각각 std::move 나 std::forward 를 적용하라.
    - 반환값 최적화의 대상이 될 수 있는 지역 객체에는 절대로 std::move 나 std::forward 를 적용하지 말아야 한다.

### 항목 26 : 보편 참조에 대한 중복적재를 피하라
- 중복 적재(오버로딩)를 할 경우 컴파일러가 생각하는 우선순위가 사람과 달라질 여지가 크다. 보편 참조가 다 잡아먹는다.
- 기억해 둘 사항들
    - 보편 참조에 대한 중복적재는 거의 항상 보편 참조 중복적재 버전이 예상보다 자주 호출되는 상황으로 이어진다.
    - 완벽 전달 생성자들은 특히나 문제가 많다. 그런 생성자는 대체로 비const 왼값에 대한 복사 생성자보다 더 나은 부합이며, 기반 클래스 복사 및 이동 생성자들에 대한 파생 클래스들의 호출들을 가로챌 수 있기 때문이다.

### 항목 27 : 보편 참조에 대한 중복적재 대신 사용할 수 있는 기법들을 알아 두라
- 기억해 둘 사항들
    - 보편 참조와 중복적재의 조합에 대한 대안으로는 구별되는 함수 이름 사용, 매개변수를 const 에 대한 왼값 참조로 전달, 매개변수를 값으로 전달, 꼬리표 배분 사용 등이 있다.
    - std::enable_if 를 이용해서 템플릿의 인스턴스화를 제한함으로써 보편 참조와 중복적재를 함께 사용할 수 있다. std::enable_if 는 컴파일러가 보편 참조 중복적재를 사용하는 조건을 프로그래머가 직접 제어하는 용도로 쓰인다.
    - 보편 참조 매개변수는 효율성 면에서 장점인 경우가 많지만, 대체로 사용성 면에서는 단점이 된다.

### 항목 28: 참조 축약을 숙지하라
- 참조에 대한 참조(왼값에 대한 왼값, 오른값에 대한 왼값, 왼값에 대한 오른값)은 모두 결과가 왼값 참조이고, 오른값에 대한 오른값의 결과만 오른값 참조이다.
- 기억해 둘 사항들
    - 참조 축약은 템플릿 인스턴스화, auto 형식 연역, typedef 과 별칭 선언의 지정 및 사용, decltype 의 지정 및 사용이라는 네 가지 문맥에서 일어난다.
    - 컴파일러가 참조 축약 문맥에서 참조에 대한 참조를 만들어내면, 그 결과는 하나의 참조가 된다. 원래의 두 참조 중 하나라도 왼값 참조이면 결과는 왼값 참조이고, 그렇지 않으면 오른값 참조이다.
    - 형식 연역이 왼값과 오른값을 구분하는 문맥과 참조 축약이 일어나는 문맥에서 보편 참조는 오른값 참조이다.

### 항목 29 : 이동 연산이 존재하지 않고, 저렴하지 않고, 적용되지 않는다고 가정하라
- std::array의 경우 이동연산이 복사연산보다 저렴하지 않다.
- 기억해 둘 사항들
    - 이동 연산들이 존재하지 않고, 저렴하지 않고, 적용되지 않을 것이라고 가정하자.
    - 형식들과 이동 의미론 지원 여부를 미리 알 수 있는 경우에는 그런 가정을 둘 필요가 없다.

### 항목 30: 완벽 전달이 실패하는 경우들을 잘 알아두라
- 기억해 둘 사항들
    - 완벽 전달은 템플릿 형식 연역이 실패하거나 틀린 형식을 연역했을 때 실패한다.
    - 인수가 중괄호 초기치이거나 0 또는 NULL 로 표현된 널 포인터, 선언만 된 정수 static const 및 constexpr 자료 멤버, 템플릿 및 중복적재된 함수 이름, 비트필드이면 완벽 전달이 실패한다.

## 6장 람다 표현식
### 항목 31 : 기본 갈무리 모드를 피하라
- 기억해 둘 사항들
    - 기본 참조 갈무리[&]는 참조가 대상을 잃을 위험이 있다.
    - 기본 값 갈무리[=]는 포인터(특히 this)가 대상을 잃을 수 있으며, 람다가 자기 완결적이라는 오해를 부를 수 있다.

### 항목 32 : 객체를 클로저 안으로 이동하려면 초기화 갈무리를 사용하라
- C++ 11은 초기화 갈무리를 지원하지 않기 떄문에 std::bind를 사용해서 우회하는 방법을 사용할 수 있다.
- 기억해 둘 사항들
    - 객체를 클로저 안으로 이동할 때에는 C++14 의 초기화 갈무리를 사용하라.
    - C++11 에서는 직접 작성한 클래스나 std::bind 로 초기화 갈무리를 흉내낼 수 있다.

### 항목 33 : std::forward 를 통해 전달할 auto&& 매개변수에는 decltype을 사용하라
- 기억해 둘 사항들
    - std::forward 를 통해 전달할 auto&& 매개변수에는 decltype을 사용하라.

### 항목 34 : std::bind보다 람다를 선호하라
- 가독성이 더 뛰어나고, 복사/이동 동작이 코드에 드러나며 컴파일러 인라인화를 통해 성능도 향상될 여지가 있다.
- 기억해 둘 사항들
    - std::bind 를 사용하는 것보다 람다가 더 읽기 쉽고 표현력이 좋다. 그리고 더 효율적이다.
    - C++14 가 아닌 C++11 에서는 이동 갈무리를 구현하거나 객체를 템플릿화된 함수 호출 연산자에 묶으려 할 때 std::bind 가 유용할 수 있다.
    
## 7장 동시성 API
### 항목 35 : 스레드 기반 프로그래밍보다 과제 기반 프로그래밍을 선호하라
- 기억해 둘 사항들
    - std::thread API 에서는 비동기적으로 실행된 함수의 반환값을 직접 얻을 수 없으며, 만일 그런 함수가 예외를 던지면 프로그램이 종료된다.
    - 스레드 기반 프로그래밍에서는 스레드 고갈, 과다구독, 부하 균형화, 새 플랫폼으로의 적응을 독자가 직접 처리해야 한다.
    - std::async 와 기본 시동 방침을 이용한 과제 기반 프로그래밍은 그런 대부분의 문제를 알아서 처리해준다.

### 항목 36 : 비동기성이 필수일 때에는 std::launch::async 를 지정하라
- 기억해 둘 사항들
    - std::async 의 기본 시동 방침은 과제의 비동기적 실행과 동기적 실행을 모두 허용한다.
    - 그러나 이러한 유연성 때문에 thread_local 접근의 불확실성이 발생하고, 과제가 절대로 실행되지 않을 수도 있고, 시간 만료 기반 wait 호출에 대한 프로그램 논리에도 영향이 간다.
    - 과제를 반드시 비동기적으로 실행해야 한다면 std::launch::async 를 지정하라.

### 항목 37 : std::thread 들을 모든 경로에서 합류 불가능하게 만들어라
- 기억해 둘 사항들
    - 모든 경로에서 std::thread 를 합류 불가능으로 만들어라.
    - 소멸 시 join 방식은 디버깅하기 어려운 성능 이상으로 이어질 수 있다.
    - 소멸 시 detach 방식은 디버깅하기 어려운 미정의 행동으로 이어질 수 있다.
    - 자료 멤버 목록에서 std::thread 객체를 마지막에 선언하라.

### 항목 38 : 스레드 핸들 소멸자들의 다양한 행동 방식을 주의하라
- 기억해 둘 사항들
    - 미래 객체의 소멸자는 그냥 미래 객체의 자료 멤버들을 파괴할 뿐이다.
    - std::async 를 통해 시동된 비지연 과제에 대한 공유 상태를 참조하는 마지막 미래 객체의 소멸자는 그 과제가 완료될 때까지 차단된다(기다린다).

### 항목 39 : 단발성 사건 통신에는 void 미래 객체를 고려하라
- 기억해 둘 사항들
    - 간단한 사건 통신을 수행할 때, 조건 변수 기반 설계에는 여분의 뮤텍스가 필요하고, 검출 과제와 반응 과제의 진행 순서에 제약이 있으며, 사건이 실제로 발생했는지를 반응 과제가 다시 확인해야 한다.
    - 플래그 기반 설계를 사용하면 그런 단점들이 없지만, 대신 차단이 아니라 폴링이 일어난다는 단점이 있다.
    - 조건 변수와 플래그를 조합할 수도 있으나, 그런 조합을 이용한 통신 메커니즘은 필요 이상으로 복잡하다.
    - std::promise 와 미래 객체를 사용하면 이러한 문제점들을 피할 수 있지만, 그런 접근 방식은 공유 상태에 힙 메모리를 사용하며, 단발성 통신만 가능하다.

### 항목 40 : 동시성에는 std::atomic 을 사용하고, volatile 은 특별한 메모리에 사용하라
- 기억해 둘 사항들
    - std::atomic 은 뮤텍스 보호 없이 여러 스레드가 접근하는 자료를 위한 것으로, 동시적 소프트웨어의 작성을 위한 도구이다.
    - volatile 은 읽기와 기록을 최적화로 제거하지 말아야 하는 메모리를 위한 것으로, 특별한 메모리를 다룰 때 필요한 도구이다.

## 8장 다듬기
### 항목 41 : 이동이 저렴하고 항상 복사되는 복사 가능 매개변수에 대해서는 값 전달을 고려하라
- 기억해 둘 사항들
    - 이동이 저렴하고 항상 복사되는 복사 가능 매개변수에 대해서는 값 전달이 참조 전달만큼이나 효율적이고, 구현하기가 더 쉽고, 산출되는 목적 코드의 크기도 더 작다.
    - 왼값 인수의 경우 값 전달(즉, 복사 생성) 다음의 이동 배정은 참조 전달 다음의 복사 배정보다 훨씬 비쌀 가능성이 있다.
    - 값 전달에서는 잘림 문제가 발생할 수 있으므로, 일반적으로 기반 클래스 매개변수 형식에 대해서는 값 전달이 적합하지 않다.

### 항목 42 : 삽입 대신 생성 삽입을 고려하라
- 기억해 둘 사항들
    - 이론적으로, 생성 삽입 함수들은 종종 해당 삽입 버전보다 더 효율적이어야 하며, 덜 효율적인 경우는 절대로 없어야 한다.
    - 실질적으로, (1) 추가할 값이 컨테이너에 배정되는 것이 컨테이너에 배정되는 것이 아니라 컨테이너 안에서 생성되고, (2) 인수 형식(들)이 컨테이너가 담는 형식과 다르고, (3) 그 값이 중복된 값이어도 컨테이너가 거부하지 않는다면, 생성 삽입 함수가 삽입 함수보다 빠를 가능성이 아주 크다.
    - 생성 삽입 함수는 삽입 함수라면 거부당했을 형식 변환들을 수행할 수 있다.