# Effective Modern C++

## 1장 형식 연역
### 항목 1: 템플릿 형식 연역 규칙을 숙지하라
- template T와 ParamType T의 형식이 달라질 수 있으니 잘 숙지해야 한다. 특히 const와 &가 사용된 경우 그러하다.
- 기억해 둘 사항들
    - 템플릿 형식 연역 도중에 참조 형식의 인수들은 비참조로 취급된다. 즉, 참조성이 무시된다.
    - 보편 참조 매개변수에 대한 형식 연역 과정에서 왼값 인수들은 특별하게 취급된다.
    - 값 전달 방식의 매개변수에 대한 형식 연역 과정에서 const 또는 volatile(또는 그 둘 다인) 인수는 비 const, 비 volatile 인수로 취급된다.
    - 템플릿 형식 연역 과정에서 배열이나 함수 이름에 해당하는 인수는 포인터로 붕괴한다. 단, 그런 인수가 참조를 초기화하는 데 쓰이는 경우에는 포인터로 붕괴하지 않는다.

### 항목 2: 항목 2: auto의 형식 연역 규칙을 숙지하라
- 기본적으로 템플릿과 동일하다. 단, auto x = { 1 } 형식의 값은 std::initializer_list\<int\>가 된다.
- 기억해 둘 사항들
    - auto 형식 연역은 대체로 템플릿 형식 연역과 같지만, auto 형식 연역은 중괄호 초기치가 std::initializer_list 를 나타낸다고 가정하는 반면, 템플릿 형식 연역은 그렇지 않다는 차이가 있다.
    - 함수의 반환 형식이나 람다 매개변수에 쓰인 auto 에 대해서는 auto 형식 연역이 아니라 템플릿 형식 연역이 적용된다.


### 항목 3: decltype의 작동 방식을 숙지하라
- template에서 decltype으로 인자와 동일한 형태를 반환하는 등의 방법으로 사용을 할 떄에는 좀 더 주의해야 한다.
- 기억해 둘 사항들
    - decltype 은 항상 변수나 표현식의 형식을 아무 수정 없이 보고한다.
    - decltype 은 형식이 T 이고 이름이 아닌 왼값 표현식에 대해서는 항상 T& 형식을 보고한다.
    - C++14 는 decltype(auto) 를 지원한다. decltype(auto)는 auto 처럼 초기치로부터 형식을 연역하지만, 그 형식 연역 과정에서 decltype 의 규칙들을 적용한다.

### 항목 4 : 연역된 형식을 파악하는 방법을 알아두라
- IDE나 std::type_info::name이 항상 완벽하지는 않다. boost::typeindex::type_id_with_cvr은 정확하긴 하지만 내가 잘 알고있는 것이 최고다.
- 기억해 둘 사항들
    - 컴파일러가 연역하는 형식을 IDE 편집기나 컴파일러 오류 메시지, Boost TypeIndex 라이브러리를 이용해서 파악할 수 있는 경우가 많다.
    - 일부 도구의 결과는 유용하지도 않고 부정확할 수 있으므로, C++ 의 형식 연역 규칙들을 제대로 이해하는 것은 여전히 필요한 일이다.

## 2장 auto
### 항목 5: 명시적 형식 선언보다는 auto를 선호하라
- 초기화 필수, 불필요한 복사 방지, 클로저 저장, 암묵적 변환 방지, 유지보수의 편리함 등의 이유로 auto를 사용하는 것이 좋다.
- 기억해 둘 사항들
    - auto 변수는 반드시 초기화 해야 하며, 이식성 또는 효율성 문제를 유발할 수 있는 형식 불일치가 발생하는 경우가 거의 없으며, 대체로 변수의 형식을 명시적으로 지정할 때보다 타자량도 더 적다.
    - auto 로 형식을 지정한 변수는 항목 2 와 항목 6 에서 설명한 문제점들을 겪을 수 있다.

### 항목 6 : auto 가 원치 않은 형식으로 연역될 때는 명시적 형식의 초기치를 사용하라
- std::vector의 [] 접근 같은 대리자 클래스를 사용할 경우엔 static_cast으로 명시적으로 바꿔서 auto에 대입한다.
- 기억해 둘 사항들
    - "보이지 않는" 대리자 형식 때문에 auto 가 초기화 표현식의 형식을 "잘못" 연역할 수 있다.
    - 형식 명시 초기치 관용구는 auto 가 원하는 형식을 연역하도록 강제한다.

## 3장 현대적 C++에 적용하기
### 항목 7: 객체 생성 시 괄호(())와 중괄호({})를 구분하라
- 중괄호 초기화는 좋긴 하지만 std::initializer_list 매개변수가 있는 경우엔 가능하면 항상 이걸 선호하므로 주의가 필요하다. 선택과 스타일의 영역.
- 기억해 둘 사항들
    - 중괄호 초기화는 가장 광범위하게 적용할 수 있는 초기화 구문이며, 좁히기 변환을 방지하며, C++ 의 가장 성가신 구문 해석에서 자유롭다.
    - 생성자 오버로딩 해소 과정에서 중괄호 초기화는 가능한 한 std::initializer_list 매개변수가 있는 생성자와 부합한다.
    - 괄호와 중괄호의 선택이 의미 있는 차이를 만드는 예는 인수 두 개로 std::vector<수치 형식> 을 생성하는 것이다.
    - 템플릿 안에서 객체를 생성할 때 괄호를 사용할 것인지 중괄호를 사용할 것인지 선택하기가 어려울 수 있다.

### 항목8: 0과 NULL보다 nullptr를 선호하라
- 템플릿에 0이나 NULL을 넘기면 int 타입으로 인식해 문제가 생길 수 있다.
- 기억해 둘 사항들
    - 0 과 NULL 보다 nullptr 를 선호하라.
    - 정수 형식과 포인터 형식에 대한 오버로딩을 피하라.

### 항목 9: typedef보다 별칭 선언을 선호하라
- using은 typedef와 동일하게 동작하지만 템플릿을 작성하는 상황에 유리하다.
- 기억해 둘 사항들
    - typedef 은 템플릿화를 지원하지 않지만, using 은 지원한다.
    - 별칭 템플릿에서는 "::type" 접미어를 붙일 필요가 없다. 템플릿 안에서 typedef 을 지칭할 때에는 "typename" 접두사를 붙여야 하는 경우가 많다.
    - C++14 는 C++11 의 모든 형식 특질 변환에 대한 using 들을 제공한다.

### 항목 10: 범위 없는 enum보다 범위 있는 enum을 선호하라
- enum class는 전방 선언, 이름 오염, 암묵적 변환 방지 등의 장점이 있다.
- 기억해 둘 사항들
    - C++98 스타일의 enum 을 이제는 범위 없는 enum 이라고 부른다.
    - 범위 있는 enum 의 열거자들은 그 안에서만 보인다. 이 열거자들은 오직 캐스팅을 통해서만 다른 형식으로 변환된다.
    - 범위 있는 enum 과 범위 없는 enum 모두 바탕 형식 지정을 지원한다. 범위 있는 enum 의 기본 바탕 형식은 int 이다. 범위 없는 enum 에는 기본 바탕 형식이 없다.
    - 범위 있는 enum 은 항상 전방 선언이 가능하다. 범위 없는 enum 은 해당 선언에 바탕 형식을 지정하는 경우에만 전방 선언이 가능하다.

### 항목 11: 정의되지 않은 비공개 함수보다 삭제된 함수를 선호하라
- 예전에 사용하던 private 선언 후 구현하지 않는 방법은 = delete가 없어서 그랬던 것.
- 기억해 둘 사항들
    - 정의되지 않은 비공개 함수보다 삭제된 함수를 선호하라.
    - 비멤버 함수와 템플릿 인스턴스를 비롯한 그 어떤 함수도 삭제할 수 있다.

### 항목 12: 재정의 함수들을 override로 선언하라
- 재정의 과정에서 실수 하거나 의도와 다르게 구현하는 것을 override와 final로 방지할 수 있다.
- 기억해 둘 사항들
    - 재정의 함수는 override 로 선언하라.
    - 멤버 함수 참조 한정사(reference qualifier)를 이용하면 멤버 함수가 호출되는 객체(*this)의 왼값 버전과 오른값 버전을 다른 방식으로 처리할 수 있다.

### 항목 13: iterator 보다 const_iterator를 선호하라
- C++11에서는 const_iterator 사용이 쉬워졌기 때문에 안 쓸 이유가 없다.
- 기억해 둘 사항들
    - iterator 보다 const_iterator 를 선호하라.
    - 최대한 일반적인 코드에서는 begin, end, rbegin 등의 비멤버 버전들을 해당 멤버 함수들보다 선호하라.

### 항목 14: 예외를 방출하지 않을 함수는 noexcept로 선언하라
- 이동, swap 등에서 noexcept를 사용하면 컴파일러 최적화 여지가 크다. 단, 한 번 사용하면 없애기 어려우므로 신중해야 한다.
- 기억해 둘 사항들
    - noexcept 는 함수의 인터페이스의 일부이다. 이는 호출자가 noexcept 여부에 의존할 수 있음을 뜻한다.
    - noexcept 함수는 비 noexcept 함수보다 최적화의 여지가 크다.
    - noexcept 는 이동 연산들과 swap, 메모리 해제 함수들, 그리고 소멸자들에 특히나 유용하다.
    - 대부분의 함수는 noexcept 가 아니라 예외에 중립적이다.

### 항목 15: 가능하면 항상 constexpr을 사용하라
- 객체와 함수가 다르게 동작하는 것을 알고, 계속 constexpr을 유지할 수 있다면 사용하는 것이 항상 좋다.
- 기억해 둘 사항들
    - constexpr 객체는 const 이며, 컴파일 도중에 알려지는 값들로 초기화된다.
    - constexpr 함수는 그 값이 컴파일 도중에 알려지는 인수들로 호출하는 경우에는 컴파일 시점 결과를 산출한다.
    - constexpr 객체나 함수는 비constexpr 객체나 함수보다 광범위한 문맥에서 사용할 수 있다.
    - constexpr 은 객체나 함수의 인터페이스의 일부이다.

### 항목 16: const 멤버 함수를 스레드에 안전하게 작성하라
- const 멤버 함수에서 의도적으로 mutable 멤버 변수를 조작할 경우 atomic, mutex 등을 이용해 스레드 안전하게 작성해야 한다.
- 기억해 둘 사항들
    - 동시적 문맥에서 쓰이지 않을 것이 확실한 경우가 아니라면, const 멤버 함수는 스레드에 안전하게 작성하라.
    - std::atomic 변수는 mutex 에 비해 성능상의 이점이 있지만, 하나의 변수 또는 메모리 장소를 다룰 때에만 적합하다.

### 항목 17: 특수 멤버 함수들의 자동 작성 조건을 숙지하라
- 소멸자, 복사, 이동 관련 함수 중 하나라도 사용자가 정의하면 이동 생성/대입은 자동 생성되지 않으므로 필요하면 = default를 통해 명시해 주는 것이 성능 하락을 방지할 수 있다.
- 기억해 둘 사항들
    - 컴파일러가 스스로 작성할 수 있는 멤버 함수들, 즉 기본 생성자와 소멸자, 복사 연산들, 이동 연산들을 가리켜 특수 멤버 함수라고 한다.
    - 이동 연산들은 이동 연산들이나 복사 연산들, 소멸자가 명시적으로 선언되어 있지 않은 클래스에 대해서만 자동으로 작성된다.
    - 복사 생성자는 복사 생성자가 명시적으로 선언되어 있지 않은 클래스에 대해서만 자동으로 작성되며, 만일 이동 연산이 하나라도 선언되어 있으면 삭제된다. 복사 배정 연산자는 복사 배정 연산자가 명시적으로 선언되어 있지 않은 클래스에 대해서만 자동으로 작성되며, 만일 이동 연산이 하나라도 선언되어 있으면 삭제된다. 소멸자가 명시적으로 선언된 클래스에서 복사 연산들이 자동으로 작성되는 기능은 비권장이다.
    - 멤버 함수 템플릿 때문에 특수 멤버 함수의 자동 작성이 금지되는 경우는 전혀 없다.

## 4장 똑똑한 포인터
### 항목 18: 소유권 독점 자원의 관리에는 std::unique_ptr를 사용하라
- std::unique_ptr에 커스텀 삭제자를 지정하여 delete 함수의 동작을 다르게 할 수도 있다.
- 커스텀 삭제자로 함수 포인터를 지정한 경우에는 std::unique_ptr의 크기가 1워드에서 2워드로 증가한다.
- 삭제자가 함수 객체일 때에는 std::unique_ptr의 크기가 그 함수 객체에 저장된 상태의 크기만큼 증가한다. 상태 없는 함수 객체(갈무리 없는 람다 표현식)의 경우에는 크기 변화가 없다. 
- 기억해 둘 사항들
    - std::unique_ptr 는 독점 소유권 의미론을 가진 자원의 관리를 위한, 작고 빠른 이동 전용 똑똑한 포인터이다.
    - 기본적으로 자원 파괴는 delete 를 통해 일어나나, 커스텀 삭제자를 지정할 수 있다. 상태 있는 삭제자나 함수 포인터를 사용하면 std::unique_ptr 객체의 크기가 커진다.
    - std::unique_ptr 를 std::shared_ptr 로 손쉽게 변환할 수 있다.

### 항목 19: 소유권 공유 자원의 관리에는 std::shared_ptr를 사용하라
- std::shared_ptr의 크기는 생 포인터의 두 배이다. 자원을 가리키는 생 포인터 뿐만 아니라 자원의 참조 횟수를 가리키는 생 포인터도 저장해야 하기 때문이다.
- std::shared_ptr의 크기는 항상 포인터 두 개 분량이기 때문에 삭제자를 지정하더라도 크기가 증가하지 않는다.
- 기억해 둘 사항들
    - std::shared_ptr 는 임의의 공유 자원의 수명을 편리하게(쓰레기 수거에 맡길 때만큼이나) 관리할 수 있는 수단을 제공한다.
    - 대체로 std::shared_ptr 객체는 그 크기가 std::shared_ptr 객체의 두 배이며, 제어 블록에 관련된 추가 부담을 유발하며, 원자적 참조 횟수 조작을 요구한다.
    - 자원은 기본적으로 delete 를 통해 파괴되나, 커스텀 삭제자도 지원된다. 삭제자의 형식은 std::shared_ptr 의 형식에 아무런 영향도 미치지 않는다.
    - 생 포인터 형식의 변수로부터 std::shared_ptr 를 생성하는 일은 피해야 한다.

### 항목 20: std::shared_ptr 처럼 작동하되 대상을 잃을 수도 있는 포인터가 필요하면 std::weak_ptr 를 사용하라
- 기억해 둘 사항들
    - std::shared_ptr 처럼 작동하되 대상을 잃을 수도 있는 포인터가 필요하면 std::weak_ptr 를 사용하라
    - std::weak_ptr 의 잠재적인 용도로는 캐싱, 관찰자 목록, 그리고 std::shared_ptr 순환 고리 방지가 있다.

### 항목 21: new 를 직접 사용하는 것보다 std::make_unique 와 std::make_shared 를 선호하라
- 코드, 속도, 메모리 사용량 면에서 효율적이다. 단, 커스텀 삭제자를 지정하거나 T의 크기가 매우 커서 weak_ptr의 사용이 끝나기까지 메모리를 붙잡고 있는게 싫은 경우엔 new를 사용하는게 더 합당할 수 있다.
- 기억해 둘 사항들
    - new 의 직접 사용에 비해, make 함수를 사용하면 소스 코드 중복의 여지가 없어지고, 예외 안전성이 향상되고, std::make_shared 와 std::allocate_shared 의 경우 더 작고 빠른 코드가 산출된다.
    - make 함수의 사용이 불가능 또는 부적합한 경우로는 커스텀 삭제자를 지정해야 하는 경우와 중괄호 초기치를 전달해야 하는 경우가 있다.
    - std::shared_ptr 에 대해서는 make 함수가 부적합한 경우가 더 있는데, 두 가지 예를 들자면 (1) 커스텀 메모리 관리 기능을 가진 클래스를 다루는 경우와 (2) 메모리가 넉넉하지 않은 시스템에서 큰 객체를 자주 다루어야 하고 std::weak_ptr 들이 해당 std::shared_ptr 들보다 더 오래 살아남는 경우이다.

### 항목 22: Pimpl 관용구를 사용할 때에는 특수 멤버 함수들을 구현 파일에서 정의하라
- unique_ptr을 사용할 경우엔 삭제자가 정의에 포함되기 때문에, 컴파일 시점에서 완전한 클래스여야 한다. 따라서 cpp 정의부로 특수 멤버 함수들의 구현을 옮겨 컴파일 에러를 피해야 한다.
- 기억해 둘 사항들
   - Pimpl 관용구는 클래스 구현과 클래스 클라이언트 사이의 컴파일 의존성을 줄임으로써 빌드 시간을 감소한다.
    - std::unique_ptr 형식의 pImpl 포인터를 사용할 때에는 특수 멤버 함수들을 클래스 헤더에 선언하고 구현 파일에서 구현해야 한다. 컴파일러가 기본으로 작성하는 함수 구현들이 사용하기에 적합한 경우에도 그렇게 해야 한다.
    - 위의 조언은 std::unique_ptr 에 적용될 뿐, std::shared_ptr 에는 적용되지 않는다.

### 항목 23: std::move와 std::forward를 숙지하라
- 기억해 둘 사항들
    - std::move 는 오른값으로의 무조건 캐스팅을 수행한다. std::move 자체는 아무것도 이동하지 않는다.
    - std::forward 는 주어진 인수가 오른값에 묶인 경우에만 그것을 오른값으로 캐스팅한다.
    - std::move 와 std::forward 둘 다, 실행 시점에서는 아무 일도 하지 않는다.

### 항목 24 : 보편 참조와 오른값 참조를 구별하라
- 기억해 둘 사항들
    - 함수 템플릿 매개변수의 형식이 T&& 형태이고 T 가 연역된다면, 또는 객체를 auto&& 로 선언한다면, 그 매개변수나 객체는 보편 참조이다.
    - 형식 선언의 형태가 정확히 형식&& 가 아니면, 또는 형식 연역이 일어나지 않으면, 형식&& 는 오른값 참조를 뜻한다.
    - 오른값으로 초기화되는 보편 참조는 오른값 참조에 해당한다. 왼값으로 초기화되는 보편 참조는 왼값 참조에 해당한다.

### 항목 25 : 오른값 참조에는 std::move 를, 보편 참조에는 std::forward 를 사용하라
- 기억해 둘 사항들
    - 오른값 참조나 보편 참조가 마지막으로 쓰이는 지점에서, 오른값 참조에는 std::move 를, 보편 참조에는 std::forward 를 적용하라.
    - 결과를 값 전달 방식으로 돌려주는 함수가 오른값 참조나 보편 참조를 돌려줄 때에도 각각 std::move 나 std::forward 를 적용하라.
    - 반환값 최적화의 대상이 될 수 있는 지역 객체에는 절대로 std::move 나 std::forward 를 적용하지 말아야 한다.

### 항목 26 : 보편 참조에 대한 중복적재를 피하라
- 중복 적재를 할 경우 컴파일러가 생각하는 우선순위가 사람과 달라질 여지가 크다. 보편 참조가 다 잡아먹는다.
- 기억해 둘 사항들
    - 보편 참조에 대한 중복적재는 거의 항상 보편 참조 중복적재 버전이 예상보다 자주 호출되는 상황으로 이어진다.
    - 완벽 전달 생성자들은 특히나 문제가 많다. 그런 생성자는 대체로 비const 왼값에 대한 복사 생성자보다 더 나은 부합이며, 기반 클래스 복사 및 이동 생성자들에 대한 파생 클래스들의 호출들을 가로챌 수 있기 때문이다.